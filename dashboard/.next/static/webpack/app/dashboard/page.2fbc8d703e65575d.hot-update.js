"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./stores/usePipelineStoreWithSupabase.ts":
/*!************************************************!*\
  !*** ./stores/usePipelineStoreWithSupabase.ts ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   usePipelineStoreWithSupabase: function() { return /* binding */ usePipelineStoreWithSupabase; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! socket.io-client */ \"(app-pages-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n\n\n\n// Convert database prospect to IProspect\nconst convertToIProspect = (dbProspect)=>{\n    var _dbProspect_location_split_, _dbProspect_location_split_1;\n    return {\n        id: dbProspect.id,\n        business: {\n            name: dbProspect.business_name,\n            industry: dbProspect.industry,\n            location: {\n                address: \"\",\n                city: ((_dbProspect_location_split_ = dbProspect.location.split(\",\")[0]) === null || _dbProspect_location_split_ === void 0 ? void 0 : _dbProspect_location_split_.trim()) || \"\",\n                state: ((_dbProspect_location_split_1 = dbProspect.location.split(\",\")[1]) === null || _dbProspect_location_split_1 === void 0 ? void 0 : _dbProspect_location_split_1.trim()) || \"\",\n                zipCode: \"\",\n                country: \"USA\",\n                coordinates: {\n                    lat: 0,\n                    lng: 0\n                }\n            },\n            website: dbProspect.website || \"\",\n            description: \"\",\n            size: {\n                category: \"small\",\n                employeeCount: 10,\n                estimatedRevenue: 500000\n            },\n            digitalPresence: {\n                hasWebsite: !!dbProspect.website,\n                hasGoogleBusiness: true,\n                hasSocialMedia: false,\n                hasOnlineReviews: false,\n                websiteUrl: dbProspect.website || undefined\n            }\n        },\n        contact: {\n            primaryContact: dbProspect.contact_name || \"\",\n            contactTitle: \"Owner\",\n            email: dbProspect.contact_email || \"\",\n            phone: dbProspect.contact_phone || \"\",\n            website: dbProspect.website || \"\",\n            decisionMaker: \"Yes\",\n            socialProfiles: {}\n        },\n        pipelineStage: dbProspect.pipeline_stage,\n        qualificationScore: {\n            total: dbProspect.score,\n            breakdown: {\n                businessSize: 15,\n                digitalPresence: 20,\n                competitorGaps: 15,\n                location: 10,\n                industry: 5,\n                revenueIndicators: 5\n            },\n            qualificationLevel: dbProspect.score > 70 ? \"high\" : dbProspect.score > 40 ? \"medium\" : \"low\",\n            lastUpdated: new Date(dbProspect.updated_at)\n        },\n        researchPasses: [\n            {\n                passNumber: 1,\n                type: \"google_maps\",\n                status: \"completed\",\n                completedAt: new Date(dbProspect.created_at),\n                dataCollected: {},\n                retryCount: 0,\n                source: {\n                    api: \"Google Maps API\"\n                }\n            },\n            {\n                passNumber: 2,\n                type: \"firecrawl\",\n                status: \"completed\",\n                completedAt: new Date(dbProspect.created_at),\n                dataCollected: {},\n                retryCount: 0,\n                source: {\n                    api: \"Firecrawl\"\n                }\n            }\n        ],\n        dataConfidence: 85,\n        businessInsights: {\n            painPoints: [\n                \"Limited online presence\"\n            ],\n            competitiveAdvantages: [\n                \"Strong local reputation\"\n            ]\n        },\n        tags: [\n            \"prospect\",\n            dbProspect.industry\n        ],\n        createdAt: new Date(dbProspect.created_at),\n        updatedAt: new Date(dbProspect.updated_at)\n    };\n};\nconst usePipelineStoreWithSupabase = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_2__.devtools)((set, get)=>({\n        // Prospects\n        prospects: [],\n        selectedProspect: null,\n        setSelectedProspect: (prospect)=>set({\n                selectedProspect: prospect\n            }),\n        // Loading states\n        isLoading: false,\n        error: null,\n        // WebSocket connection\n        socket: null,\n        wsConnected: false,\n        wsConnecting: false,\n        // Filtering\n        stageFilter: \"all\",\n        setStageFilter: (stage)=>set({\n                stageFilter: stage\n            }),\n        industryFilter: \"all\",\n        setIndustryFilter: (industry)=>set({\n                industryFilter: industry\n            }),\n        searchQuery: \"\",\n        setSearchQuery: (query)=>set({\n                searchQuery: query\n            }),\n        // Actions\n        fetchProspects: async ()=>{\n            set({\n                isLoading: true,\n                error: null\n            });\n            try {\n                const response = await fetch(\"/api/prospects\");\n                const result = await response.json();\n                if (result.success) {\n                    const prospects = result.data.map(convertToIProspect);\n                    set({\n                        prospects,\n                        isLoading: false\n                    });\n                } else {\n                    set({\n                        error: result.error || \"Failed to fetch prospects\",\n                        isLoading: false\n                    });\n                }\n            } catch (error) {\n                set({\n                    error: \"Failed to fetch prospects\",\n                    isLoading: false\n                });\n                console.error(\"Error fetching prospects:\", error);\n            }\n        },\n        moveProspect: async (prospectId, newStage)=>{\n            try {\n                const response = await fetch(\"/api/prospects?id=\".concat(prospectId), {\n                    method: \"PUT\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        pipeline_stage: newStage\n                    })\n                });\n                const result = await response.json();\n                if (result.success) {\n                    // Update local state optimistically\n                    set((state)=>({\n                            prospects: state.prospects.map((p)=>p.id === prospectId ? {\n                                    ...p,\n                                    pipelineStage: newStage\n                                } : p)\n                        }));\n                } else {\n                    set({\n                        error: result.error || \"Failed to update prospect stage\"\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error moving prospect:\", error);\n                set({\n                    error: \"Failed to update prospect stage\"\n                });\n            }\n        },\n        updateProspectScore: async (prospectId, score)=>{\n            try {\n                const response = await fetch(\"/api/prospects?id=\".concat(prospectId), {\n                    method: \"PUT\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        score\n                    })\n                });\n                const result = await response.json();\n                if (result.success) {\n                    // Update local state\n                    set((state)=>({\n                            prospects: state.prospects.map((p)=>p.id === prospectId ? {\n                                    ...p,\n                                    qualificationScore: {\n                                        ...p.qualificationScore,\n                                        total: score,\n                                        qualificationLevel: score > 70 ? \"high\" : score > 40 ? \"medium\" : \"low\",\n                                        lastUpdated: new Date()\n                                    }\n                                } : p)\n                        }));\n                } else {\n                    set({\n                        error: result.error || \"Failed to update prospect score\"\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error updating prospect score:\", error);\n                set({\n                    error: \"Failed to update prospect score\"\n                });\n            }\n        },\n        addProspect: async (prospect)=>{\n            try {\n                const response = await fetch(\"/api/prospects\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        business_name: prospect.business.name,\n                        industry: prospect.business.industry,\n                        location: \"\".concat(prospect.business.location.city, \", \").concat(prospect.business.location.state),\n                        contact_name: prospect.contact.primaryContact,\n                        contact_email: prospect.contact.email,\n                        contact_phone: prospect.contact.phone,\n                        website: prospect.business.website,\n                        temperature: prospect.temperature,\n                        pipeline_stage: prospect.pipelineStage,\n                        score: prospect.qualificationScore.total,\n                        notes: prospect.notes\n                    })\n                });\n                const result = await response.json();\n                if (result.success) {\n                    const iProspect = convertToIProspect(result.data);\n                    set((state)=>({\n                            prospects: [\n                                ...state.prospects,\n                                iProspect\n                            ]\n                        }));\n                    get().addNotification({\n                        type: \"success\",\n                        message: \"Prospect \".concat(iProspect.business.name, \" added successfully\")\n                    });\n                } else {\n                    set({\n                        error: result.error || \"Failed to add prospect\"\n                    });\n                    get().addNotification({\n                        type: \"error\",\n                        message: result.error || \"Failed to add prospect\"\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error adding prospect:\", error);\n                set({\n                    error: \"Failed to add prospect\"\n                });\n                get().addNotification({\n                    type: \"error\",\n                    message: \"Failed to add prospect\"\n                });\n            }\n        },\n        updateProspect: async (prospectId, updates)=>{\n            try {\n                const response = await fetch(\"/api/prospects?id=\".concat(prospectId), {\n                    method: \"PUT\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify(updates)\n                });\n                const result = await response.json();\n                if (result.success) {\n                    const updatedIProspect = convertToIProspect(result.data);\n                    set((state)=>({\n                            prospects: state.prospects.map((p)=>p.id === prospectId ? updatedIProspect : p)\n                        }));\n                    get().addNotification({\n                        type: \"success\",\n                        message: \"Prospect \".concat(updatedIProspect.business.name, \" updated successfully\")\n                    });\n                } else {\n                    set({\n                        error: result.error || \"Failed to update prospect\"\n                    });\n                    get().addNotification({\n                        type: \"error\",\n                        message: result.error || \"Failed to update prospect\"\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error updating prospect:\", error);\n                set({\n                    error: \"Failed to update prospect\"\n                });\n                get().addNotification({\n                    type: \"error\",\n                    message: \"Failed to update prospect\"\n                });\n            }\n        },\n        deleteProspect: async (prospectId)=>{\n            // Note: Needs delete implementation in supabaseHelpers\n            set((state)=>{\n                var _state_selectedProspect;\n                return {\n                    prospects: state.prospects.filter((p)=>p.id !== prospectId),\n                    selectedProspect: ((_state_selectedProspect = state.selectedProspect) === null || _state_selectedProspect === void 0 ? void 0 : _state_selectedProspect.id) === prospectId ? null : state.selectedProspect\n                };\n            });\n        },\n        // WebSocket connection management\n        connectWebSocket: ()=>{\n            var _state_socket;\n            const state = get();\n            if (((_state_socket = state.socket) === null || _state_socket === void 0 ? void 0 : _state_socket.connected) || state.wsConnecting) return;\n            set({\n                wsConnecting: true,\n                error: null\n            });\n            try {\n                const socket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_0__.io)(\"http://localhost:3001\", {\n                    transports: [\n                        \"websocket\"\n                    ],\n                    timeout: 5000,\n                    forceNew: true\n                });\n                socket.on(\"connect\", ()=>{\n                    console.log(\"WebSocket connected to prospect updates\");\n                    set({\n                        socket,\n                        wsConnected: true,\n                        wsConnecting: false,\n                        error: null\n                    });\n                    // Subscribe to changes automatically on connect\n                    get().subscribeToChanges();\n                });\n                socket.on(\"disconnect\", (reason)=>{\n                    console.log(\"WebSocket disconnected:\", reason);\n                    set({\n                        wsConnected: false\n                    });\n                });\n                socket.on(\"connect_error\", (error)=>{\n                    console.error(\"WebSocket connection error:\", error);\n                    set({\n                        wsConnecting: false,\n                        wsConnected: false,\n                        error: \"Failed to connect to real-time updates\"\n                    });\n                });\n                set({\n                    socket\n                });\n            } catch (error) {\n                console.error(\"Failed to create WebSocket connection:\", error);\n                set({\n                    wsConnecting: false,\n                    error: \"Failed to initialize real-time updates\"\n                });\n            }\n        },\n        disconnectWebSocket: ()=>{\n            const state = get();\n            if (state.socket) {\n                state.socket.disconnect();\n                set({\n                    socket: null,\n                    wsConnected: false,\n                    wsConnecting: false\n                });\n            }\n        },\n        // Real-time event subscriptions\n        subscribeToChanges: ()=>{\n            const state = get();\n            if (!state.socket) return;\n            // Listen for prospect updates\n            state.socket.on(\"prospect:updated\", (data)=>{\n                var _updates_business;\n                const { prospectId, updates } = data;\n                set((state)=>({\n                        prospects: state.prospects.map((p)=>p.id === prospectId ? {\n                                ...p,\n                                ...updates\n                            } : p)\n                    }));\n                get().addNotification({\n                    type: \"info\",\n                    message: \"Prospect \".concat(((_updates_business = updates.business) === null || _updates_business === void 0 ? void 0 : _updates_business.name) || prospectId, \" updated\")\n                });\n            });\n            // Listen for prospect stage changes\n            state.socket.on(\"prospect:stage_changed\", (data)=>{\n                const { prospectId, newStage, oldStage } = data;\n                set((state)=>({\n                        prospects: state.prospects.map((p)=>p.id === prospectId ? {\n                                ...p,\n                                pipelineStage: newStage\n                            } : p)\n                    }));\n                get().addNotification({\n                    type: \"success\",\n                    message: \"Prospect moved from \".concat(oldStage, \" to \").concat(newStage)\n                });\n            });\n            // Listen for new prospects\n            state.socket.on(\"prospect:created\", (data)=>{\n                const newProspect = convertToIProspect(data.prospect);\n                set((state)=>({\n                        prospects: [\n                            ...state.prospects,\n                            newProspect\n                        ]\n                    }));\n                get().addNotification({\n                    type: \"success\",\n                    message: \"New prospect added: \".concat(newProspect.business.name)\n                });\n            });\n            // Listen for research progress\n            state.socket.on(\"research:progress\", (data)=>{\n                const { prospectId, stage, progress } = data;\n                get().addNotification({\n                    type: \"info\",\n                    message: \"Research \".concat(stage, \" (\").concat(progress, \"%) for prospect \").concat(prospectId)\n                });\n            });\n            state.socket.on(\"research:completed\", (data)=>{\n                const { prospectId, success } = data;\n                if (success) {\n                    // Refresh prospect data\n                    get().fetchProspects();\n                    get().addNotification({\n                        type: \"success\",\n                        message: \"Research completed for prospect \".concat(prospectId)\n                    });\n                }\n            });\n            // System alerts\n            state.socket.on(\"system:alert\", (data)=>{\n                const { level, message } = data;\n                get().addNotification({\n                    type: level === \"error\" ? \"error\" : level === \"warning\" ? \"warning\" : \"info\",\n                    message\n                });\n            });\n            console.log(\"Subscribed to real-time prospect updates\");\n        },\n        unsubscribeFromChanges: ()=>{\n            const state = get();\n            if (state.socket) {\n                state.socket.off(\"prospect:updated\");\n                state.socket.off(\"prospect:stage_changed\");\n                state.socket.off(\"prospect:created\");\n                state.socket.off(\"research:progress\");\n                state.socket.off(\"research:completed\");\n                state.socket.off(\"system:alert\");\n                console.log(\"Unsubscribed from real-time updates\");\n            }\n        },\n        // Research\n        researchQueue: [],\n        addToResearchQueue: (prospectId)=>set((state)=>({\n                    researchQueue: [\n                        ...state.researchQueue,\n                        prospectId\n                    ]\n                })),\n        removeFromResearchQueue: (prospectId)=>set((state)=>({\n                    researchQueue: state.researchQueue.filter((id)=>id !== prospectId)\n                })),\n        isResearching: false,\n        setIsResearching: (researching)=>set({\n                isResearching: researching\n            }),\n        // Notifications\n        notifications: [],\n        addNotification: (notification)=>{\n            const id = \"notification-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9));\n            const newNotification = {\n                ...notification,\n                id,\n                timestamp: new Date()\n            };\n            set((state)=>({\n                    notifications: [\n                        ...state.notifications,\n                        newNotification\n                    ]\n                }));\n            // Auto-remove info notifications after 5 seconds\n            if (notification.type === \"info\") {\n                setTimeout(()=>{\n                    get().removeNotification(id);\n                }, 5000);\n            } else if (notification.type === \"success\") {\n                setTimeout(()=>{\n                    get().removeNotification(id);\n                }, 3000);\n            }\n        },\n        removeNotification: (id)=>{\n            set((state)=>({\n                    notifications: state.notifications.filter((n)=>n.id !== id)\n                }));\n        },\n        // Computed values\n        getFilteredProspects: ()=>{\n            const state = get();\n            let filtered = [\n                ...state.prospects\n            ];\n            // Stage filter\n            if (state.stageFilter !== \"all\") {\n                filtered = filtered.filter((p)=>p.pipelineStage === state.stageFilter);\n            }\n            // Industry filter\n            if (state.industryFilter !== \"all\") {\n                filtered = filtered.filter((p)=>p.business.industry === state.industryFilter);\n            }\n            // Search\n            if (state.searchQuery) {\n                const query = state.searchQuery.toLowerCase();\n                filtered = filtered.filter((p)=>p.business.name.toLowerCase().includes(query) || p.contact.primaryContact.toLowerCase().includes(query) || p.business.location.city.toLowerCase().includes(query));\n            }\n            return filtered;\n        },\n        getStageCount: (stage)=>{\n            const state = get();\n            if (stage === \"cold\") {\n                return state.prospects.filter((p)=>p.temperature === \"cold\").length;\n            }\n            return state.prospects.filter((p)=>p.pipelineStage === stage).length;\n        }\n    }), {\n    name: \"pipeline-store\"\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3Jlcy91c2VQaXBlbGluZVN0b3JlV2l0aFN1cGFiYXNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUM7QUFDYTtBQUVBO0FBcUI5Qyx5Q0FBeUM7QUFDekMsTUFBTUcscUJBQXFCLENBQUNDO1FBUWRBLDZCQUNDQTtJQVJiLE9BQU87UUFDTEMsSUFBSUQsV0FBV0MsRUFBRTtRQUNqQkMsVUFBVTtZQUNSQyxNQUFNSCxXQUFXSSxhQUFhO1lBQzlCQyxVQUFVTCxXQUFXSyxRQUFRO1lBQzdCQyxVQUFVO2dCQUNSQyxTQUFTO2dCQUNUQyxNQUFNUixFQUFBQSw4QkFBQUEsV0FBV00sUUFBUSxDQUFDRyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsY0FBakNULGtEQUFBQSw0QkFBbUNVLElBQUksT0FBTTtnQkFDbkRDLE9BQU9YLEVBQUFBLCtCQUFBQSxXQUFXTSxRQUFRLENBQUNHLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxjQUFqQ1QsbURBQUFBLDZCQUFtQ1UsSUFBSSxPQUFNO2dCQUNwREUsU0FBUztnQkFDVEMsU0FBUztnQkFDVEMsYUFBYTtvQkFBRUMsS0FBSztvQkFBR0MsS0FBSztnQkFBRTtZQUNoQztZQUNBQyxTQUFTakIsV0FBV2lCLE9BQU8sSUFBSTtZQUMvQkMsYUFBYTtZQUNiQyxNQUFNO2dCQUNKQyxVQUFVO2dCQUNWQyxlQUFlO2dCQUNmQyxrQkFBa0I7WUFDcEI7WUFDQUMsaUJBQWlCO2dCQUNmQyxZQUFZLENBQUMsQ0FBQ3hCLFdBQVdpQixPQUFPO2dCQUNoQ1EsbUJBQW1CO2dCQUNuQkMsZ0JBQWdCO2dCQUNoQkMsa0JBQWtCO2dCQUNsQkMsWUFBWTVCLFdBQVdpQixPQUFPLElBQUlZO1lBQ3BDO1FBQ0Y7UUFDQUMsU0FBUztZQUNQQyxnQkFBZ0IvQixXQUFXZ0MsWUFBWSxJQUFJO1lBQzNDQyxjQUFjO1lBQ2RDLE9BQU9sQyxXQUFXbUMsYUFBYSxJQUFJO1lBQ25DQyxPQUFPcEMsV0FBV3FD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QVdBLFNBQVNyQyxNQUFNLENBQUNaLENBQUFBLElBQ3pCQSxFQUFFekcsUUFBUSxDQUFDQyxJQUFJLENBQUMwSixXQUFXLEdBQUdDLFFBQVEsQ0FBQ3JFLFVBQ3ZDa0IsRUFBRTdFLE9BQU8sQ0FBQ0MsY0FBYyxDQUFDOEgsV0FBVyxHQUFHQyxRQUFRLENBQUNyRSxVQUNoRGtCLEVBQUV6RyxRQUFRLENBQUNJLFFBQVEsQ0FBQ0UsSUFBSSxDQUFDcUosV0FBVyxHQUFHQyxRQUFRLENBQUNyRTtZQUVwRDtZQUVBLE9BQU9tRTtRQUNUO1FBRUFHLGVBQWUsQ0FBQzNFO1lBQ2QsTUFBTXpFLFFBQVE2RDtZQUNkLElBQUlZLFVBQVUsUUFBUTtnQkFDcEIsT0FBT3pFLE1BQU04RCxTQUFTLENBQUM4QyxNQUFNLENBQUNaLENBQUFBLElBQUtBLEVBQUVHLFdBQVcsS0FBSyxRQUFRa0QsTUFBTTtZQUNyRTtZQUNBLE9BQU9ySixNQUFNOEQsU0FBUyxDQUFDOEMsTUFBTSxDQUFDWixDQUFBQSxJQUFLQSxFQUFFbkUsYUFBYSxLQUFLNEMsT0FBTzRFLE1BQU07UUFDdEU7SUFDRixJQUNBO0lBQ0U3SixNQUFNO0FBQ1IsSUFFRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zdG9yZXMvdXNlUGlwZWxpbmVTdG9yZVdpdGhTdXBhYmFzZS50cz84MzkwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJ3p1c3RhbmQnO1xuaW1wb3J0IHsgZGV2dG9vbHMgfSBmcm9tICd6dXN0YW5kL21pZGRsZXdhcmUnO1xuaW1wb3J0IHsgSVByb3NwZWN0LCBQaXBlbGluZVN0YWdlIH0gZnJvbSAnQC90eXBlcyc7XG5pbXBvcnQgeyBpbywgU29ja2V0IH0gZnJvbSAnc29ja2V0LmlvLWNsaWVudCc7XG5cbi8vIERhdGFiYXNlIHByb3NwZWN0IHR5cGUgKGZyb20gQVBJKVxuaW50ZXJmYWNlIERhdGFiYXNlUHJvc3BlY3Qge1xuICBpZDogc3RyaW5nO1xuICBidXNpbmVzc19uYW1lOiBzdHJpbmc7XG4gIGluZHVzdHJ5OiBzdHJpbmc7XG4gIGxvY2F0aW9uOiBzdHJpbmc7XG4gIGNvbnRhY3RfbmFtZTogc3RyaW5nIHwgbnVsbDtcbiAgY29udGFjdF9lbWFpbDogc3RyaW5nIHwgbnVsbDtcbiAgY29udGFjdF9waG9uZTogc3RyaW5nIHwgbnVsbDtcbiAgd2Vic2l0ZTogc3RyaW5nIHwgbnVsbDtcbiAgdGVtcGVyYXR1cmU6ICdjb2xkJyB8ICd3YXJtJyB8ICdob3QnO1xuICBwaXBlbGluZV9zdGFnZTogJ2NvbGQnIHwgJ2NvbnRhY3RlZCcgfCAnaW50ZXJlc3RlZCcgfCAncXVhbGlmaWVkJztcbiAgc2NvcmU6IG51bWJlcjtcbiAgcmVzZWFyY2hfZGF0YTogYW55O1xuICBub3Rlczogc3RyaW5nIHwgbnVsbDtcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xuICB1cGRhdGVkX2F0OiBzdHJpbmc7XG59XG5cbi8vIENvbnZlcnQgZGF0YWJhc2UgcHJvc3BlY3QgdG8gSVByb3NwZWN0XG5jb25zdCBjb252ZXJ0VG9JUHJvc3BlY3QgPSAoZGJQcm9zcGVjdDogRGF0YWJhc2VQcm9zcGVjdCk6IElQcm9zcGVjdCA9PiB7XG4gIHJldHVybiB7XG4gICAgaWQ6IGRiUHJvc3BlY3QuaWQsXG4gICAgYnVzaW5lc3M6IHtcbiAgICAgIG5hbWU6IGRiUHJvc3BlY3QuYnVzaW5lc3NfbmFtZSxcbiAgICAgIGluZHVzdHJ5OiBkYlByb3NwZWN0LmluZHVzdHJ5LFxuICAgICAgbG9jYXRpb246IHtcbiAgICAgICAgYWRkcmVzczogJycsXG4gICAgICAgIGNpdHk6IGRiUHJvc3BlY3QubG9jYXRpb24uc3BsaXQoJywnKVswXT8udHJpbSgpIHx8ICcnLFxuICAgICAgICBzdGF0ZTogZGJQcm9zcGVjdC5sb2NhdGlvbi5zcGxpdCgnLCcpWzFdPy50cmltKCkgfHwgJycsXG4gICAgICAgIHppcENvZGU6ICcnLFxuICAgICAgICBjb3VudHJ5OiAnVVNBJyxcbiAgICAgICAgY29vcmRpbmF0ZXM6IHsgbGF0OiAwLCBsbmc6IDAgfVxuICAgICAgfSxcbiAgICAgIHdlYnNpdGU6IGRiUHJvc3BlY3Qud2Vic2l0ZSB8fCAnJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnJyxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgY2F0ZWdvcnk6ICdzbWFsbCcgYXMgYW55LFxuICAgICAgICBlbXBsb3llZUNvdW50OiAxMCxcbiAgICAgICAgZXN0aW1hdGVkUmV2ZW51ZTogNTAwMDAwXG4gICAgICB9LFxuICAgICAgZGlnaXRhbFByZXNlbmNlOiB7XG4gICAgICAgIGhhc1dlYnNpdGU6ICEhZGJQcm9zcGVjdC53ZWJzaXRlLFxuICAgICAgICBoYXNHb29nbGVCdXNpbmVzczogdHJ1ZSxcbiAgICAgICAgaGFzU29jaWFsTWVkaWE6IGZhbHNlLFxuICAgICAgICBoYXNPbmxpbmVSZXZpZXdzOiBmYWxzZSxcbiAgICAgICAgd2Vic2l0ZVVybDogZGJQcm9zcGVjdC53ZWJzaXRlIHx8IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH0sXG4gICAgY29udGFjdDoge1xuICAgICAgcHJpbWFyeUNvbnRhY3Q6IGRiUHJvc3BlY3QuY29udGFjdF9uYW1lIHx8ICcnLFxuICAgICAgY29udGFjdFRpdGxlOiAnT3duZXInLFxuICAgICAgZW1haWw6IGRiUHJvc3BlY3QuY29udGFjdF9lbWFpbCB8fCAnJyxcbiAgICAgIHBob25lOiBkYlByb3NwZWN0LmNvbnRhY3RfcGhvbmUgfHwgJycsXG4gICAgICB3ZWJzaXRlOiBkYlByb3NwZWN0LndlYnNpdGUgfHwgJycsXG4gICAgICBkZWNpc2lvbk1ha2VyOiAnWWVzJyxcbiAgICAgIHNvY2lhbFByb2ZpbGVzOiB7fVxuICAgIH0sXG4gICAgcGlwZWxpbmVTdGFnZTogZGJQcm9zcGVjdC5waXBlbGluZV9zdGFnZSBhcyBQaXBlbGluZVN0YWdlLFxuICAgIHF1YWxpZmljYXRpb25TY29yZToge1xuICAgICAgdG90YWw6IGRiUHJvc3BlY3Quc2NvcmUsXG4gICAgICBicmVha2Rvd246IHtcbiAgICAgICAgYnVzaW5lc3NTaXplOiAxNSxcbiAgICAgICAgZGlnaXRhbFByZXNlbmNlOiAyMCxcbiAgICAgICAgY29tcGV0aXRvckdhcHM6IDE1LFxuICAgICAgICBsb2NhdGlvbjogMTAsXG4gICAgICAgIGluZHVzdHJ5OiA1LFxuICAgICAgICByZXZlbnVlSW5kaWNhdG9yczogNVxuICAgICAgfSxcbiAgICAgIHF1YWxpZmljYXRpb25MZXZlbDogZGJQcm9zcGVjdC5zY29yZSA+IDcwID8gJ2hpZ2gnIDogZGJQcm9zcGVjdC5zY29yZSA+IDQwID8gJ21lZGl1bScgOiAnbG93JyxcbiAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZShkYlByb3NwZWN0LnVwZGF0ZWRfYXQpXG4gICAgfSxcbiAgICByZXNlYXJjaFBhc3NlczogW1xuICAgICAge1xuICAgICAgICBwYXNzTnVtYmVyOiAxLFxuICAgICAgICB0eXBlOiAnZ29vZ2xlX21hcHMnLFxuICAgICAgICBzdGF0dXM6ICdjb21wbGV0ZWQnLFxuICAgICAgICBjb21wbGV0ZWRBdDogbmV3IERhdGUoZGJQcm9zcGVjdC5jcmVhdGVkX2F0KSxcbiAgICAgICAgZGF0YUNvbGxlY3RlZDoge30sXG4gICAgICAgIHJldHJ5Q291bnQ6IDAsXG4gICAgICAgIHNvdXJjZTogeyBhcGk6ICdHb29nbGUgTWFwcyBBUEknIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhc3NOdW1iZXI6IDIsXG4gICAgICAgIHR5cGU6ICdmaXJlY3Jhd2wnLFxuICAgICAgICBzdGF0dXM6ICdjb21wbGV0ZWQnLFxuICAgICAgICBjb21wbGV0ZWRBdDogbmV3IERhdGUoZGJQcm9zcGVjdC5jcmVhdGVkX2F0KSxcbiAgICAgICAgZGF0YUNvbGxlY3RlZDoge30sXG4gICAgICAgIHJldHJ5Q291bnQ6IDAsXG4gICAgICAgIHNvdXJjZTogeyBhcGk6ICdGaXJlY3Jhd2wnIH1cbiAgICAgIH1cbiAgICBdLFxuICAgIGRhdGFDb25maWRlbmNlOiA4NSxcbiAgICBidXNpbmVzc0luc2lnaHRzOiB7XG4gICAgICBwYWluUG9pbnRzOiBbJ0xpbWl0ZWQgb25saW5lIHByZXNlbmNlJ10sXG4gICAgICBjb21wZXRpdGl2ZUFkdmFudGFnZXM6IFsnU3Ryb25nIGxvY2FsIHJlcHV0YXRpb24nXVxuICAgIH0sXG4gICAgdGFnczogWydwcm9zcGVjdCcsIGRiUHJvc3BlY3QuaW5kdXN0cnldLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoZGJQcm9zcGVjdC5jcmVhdGVkX2F0KSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKGRiUHJvc3BlY3QudXBkYXRlZF9hdClcbiAgfTtcbn07XG5cbmludGVyZmFjZSBQaXBlbGluZVN0YXRlIHtcbiAgLy8gUHJvc3BlY3RzXG4gIHByb3NwZWN0czogSVByb3NwZWN0W107XG4gIHNlbGVjdGVkUHJvc3BlY3Q6IElQcm9zcGVjdCB8IG51bGw7XG4gIHNldFNlbGVjdGVkUHJvc3BlY3Q6IChwcm9zcGVjdDogSVByb3NwZWN0IHwgbnVsbCkgPT4gdm9pZDtcblxuICAvLyBMb2FkaW5nIHN0YXRlc1xuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIGVycm9yOiBzdHJpbmcgfCBudWxsO1xuXG4gIC8vIFJlYWwtdGltZSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICBzb2NrZXQ6IFNvY2tldCB8IG51bGw7XG4gIHdzQ29ubmVjdGVkOiBib29sZWFuO1xuICB3c0Nvbm5lY3Rpbmc6IGJvb2xlYW47XG5cbiAgLy8gRmlsdGVyaW5nXG4gIHN0YWdlRmlsdGVyOiBQaXBlbGluZVN0YWdlIHwgJ2FsbCc7XG4gIHNldFN0YWdlRmlsdGVyOiAoc3RhZ2U6IFBpcGVsaW5lU3RhZ2UgfCAnYWxsJykgPT4gdm9pZDtcbiAgaW5kdXN0cnlGaWx0ZXI6IHN0cmluZyB8ICdhbGwnO1xuICBzZXRJbmR1c3RyeUZpbHRlcjogKGluZHVzdHJ5OiBzdHJpbmcgfCAnYWxsJykgPT4gdm9pZDtcbiAgc2VhcmNoUXVlcnk6IHN0cmluZztcbiAgc2V0U2VhcmNoUXVlcnk6IChxdWVyeTogc3RyaW5nKSA9PiB2b2lkO1xuXG4gIC8vIEFjdGlvbnNcbiAgZmV0Y2hQcm9zcGVjdHM6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIG1vdmVQcm9zcGVjdDogKHByb3NwZWN0SWQ6IHN0cmluZywgbmV3U3RhZ2U6IFBpcGVsaW5lU3RhZ2UpID0+IFByb21pc2U8dm9pZD47XG4gIHVwZGF0ZVByb3NwZWN0U2NvcmU6IChwcm9zcGVjdElkOiBzdHJpbmcsIHNjb3JlOiBudW1iZXIpID0+IFByb21pc2U8dm9pZD47XG4gIGFkZFByb3NwZWN0OiAocHJvc3BlY3Q6IE9taXQ8SVByb3NwZWN0LCAnaWQnPikgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZGVsZXRlUHJvc3BlY3Q6IChwcm9zcGVjdElkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG5cbiAgLy8gUmVhbC10aW1lIFdlYlNvY2tldFxuICBjb25uZWN0V2ViU29ja2V0OiAoKSA9PiB2b2lkO1xuICBkaXNjb25uZWN0V2ViU29ja2V0OiAoKSA9PiB2b2lkO1xuICBzdWJzY3JpYmVUb0NoYW5nZXM6ICgpID0+IHZvaWQ7XG4gIHVuc3Vic2NyaWJlRnJvbUNoYW5nZXM6ICgpID0+IHZvaWQ7XG5cbiAgLy8gUmVzZWFyY2hcbiAgcmVzZWFyY2hRdWV1ZTogc3RyaW5nW107XG4gIGFkZFRvUmVzZWFyY2hRdWV1ZTogKHByb3NwZWN0SWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgcmVtb3ZlRnJvbVJlc2VhcmNoUXVldWU6IChwcm9zcGVjdElkOiBzdHJpbmcpID0+IHZvaWQ7XG4gIGlzUmVzZWFyY2hpbmc6IGJvb2xlYW47XG4gIHNldElzUmVzZWFyY2hpbmc6IChyZXNlYXJjaGluZzogYm9vbGVhbikgPT4gdm9pZDtcblxuICAvLyBOb3RpZmljYXRpb25zXG4gIG5vdGlmaWNhdGlvbnM6IEFycmF5PHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHR5cGU6ICdpbmZvJyB8ICdzdWNjZXNzJyB8ICd3YXJuaW5nJyB8ICdlcnJvcic7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIHRpbWVzdGFtcDogRGF0ZTtcbiAgfT47XG4gIGFkZE5vdGlmaWNhdGlvbjogKG5vdGlmaWNhdGlvbjogT21pdDxQaXBlbGluZVN0YXRlWydub3RpZmljYXRpb25zJ11bMF0sICdpZCcgfCAndGltZXN0YW1wJz4pID0+IHZvaWQ7XG4gIHJlbW92ZU5vdGlmaWNhdGlvbjogKGlkOiBzdHJpbmcpID0+IHZvaWQ7XG5cbiAgLy8gQ29tcHV0ZWQgdmFsdWVzXG4gIGdldEZpbHRlcmVkUHJvc3BlY3RzOiAoKSA9PiBJUHJvc3BlY3RbXTtcbiAgZ2V0U3RhZ2VDb3VudDogKHN0YWdlOiBQaXBlbGluZVN0YWdlKSA9PiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCB1c2VQaXBlbGluZVN0b3JlV2l0aFN1cGFiYXNlID0gY3JlYXRlPFBpcGVsaW5lU3RhdGU+KCkoXG4gIGRldnRvb2xzKFxuICAgIChzZXQsIGdldCkgPT4gKHtcbiAgICAgIC8vIFByb3NwZWN0c1xuICAgICAgcHJvc3BlY3RzOiBbXSxcbiAgICAgIHNlbGVjdGVkUHJvc3BlY3Q6IG51bGwsXG4gICAgICBzZXRTZWxlY3RlZFByb3NwZWN0OiAocHJvc3BlY3QpID0+IHNldCh7IHNlbGVjdGVkUHJvc3BlY3Q6IHByb3NwZWN0IH0pLFxuXG4gICAgICAvLyBMb2FkaW5nIHN0YXRlc1xuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIGVycm9yOiBudWxsLFxuXG4gICAgICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgICAgc29ja2V0OiBudWxsLFxuICAgICAgd3NDb25uZWN0ZWQ6IGZhbHNlLFxuICAgICAgd3NDb25uZWN0aW5nOiBmYWxzZSxcbiAgICAgIFxuICAgICAgLy8gRmlsdGVyaW5nXG4gICAgICBzdGFnZUZpbHRlcjogJ2FsbCcsXG4gICAgICBzZXRTdGFnZUZpbHRlcjogKHN0YWdlKSA9PiBzZXQoeyBzdGFnZUZpbHRlcjogc3RhZ2UgfSksXG4gICAgICBpbmR1c3RyeUZpbHRlcjogJ2FsbCcsXG4gICAgICBzZXRJbmR1c3RyeUZpbHRlcjogKGluZHVzdHJ5KSA9PiBzZXQoeyBpbmR1c3RyeUZpbHRlcjogaW5kdXN0cnkgfSksXG4gICAgICBzZWFyY2hRdWVyeTogJycsXG4gICAgICBzZXRTZWFyY2hRdWVyeTogKHF1ZXJ5KSA9PiBzZXQoeyBzZWFyY2hRdWVyeTogcXVlcnkgfSksXG4gICAgICBcbiAgICAgIC8vIEFjdGlvbnNcbiAgICAgIGZldGNoUHJvc3BlY3RzOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIHNldCh7IGlzTG9hZGluZzogdHJ1ZSwgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9wcm9zcGVjdHMnKTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3NwZWN0cyA9IHJlc3VsdC5kYXRhLm1hcChjb252ZXJ0VG9JUHJvc3BlY3QpO1xuICAgICAgICAgICAgc2V0KHsgcHJvc3BlY3RzLCBpc0xvYWRpbmc6IGZhbHNlIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXQoeyBlcnJvcjogcmVzdWx0LmVycm9yIHx8ICdGYWlsZWQgdG8gZmV0Y2ggcHJvc3BlY3RzJywgaXNMb2FkaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgc2V0KHsgZXJyb3I6ICdGYWlsZWQgdG8gZmV0Y2ggcHJvc3BlY3RzJywgaXNMb2FkaW5nOiBmYWxzZSB9KTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9zcGVjdHM6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXG4gICAgICBtb3ZlUHJvc3BlY3Q6IGFzeW5jIChwcm9zcGVjdElkLCBuZXdTdGFnZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvcHJvc3BlY3RzP2lkPSR7cHJvc3BlY3RJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHBpcGVsaW5lX3N0YWdlOiBuZXdTdGFnZSB9KVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGxvY2FsIHN0YXRlIG9wdGltaXN0aWNhbGx5XG4gICAgICAgICAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgICBwcm9zcGVjdHM6IHN0YXRlLnByb3NwZWN0cy5tYXAocCA9PlxuICAgICAgICAgICAgICAgIHAuaWQgPT09IHByb3NwZWN0SWQgPyB7IC4uLnAsIHBpcGVsaW5lU3RhZ2U6IG5ld1N0YWdlIH0gOiBwXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0KHsgZXJyb3I6IHJlc3VsdC5lcnJvciB8fCAnRmFpbGVkIHRvIHVwZGF0ZSBwcm9zcGVjdCBzdGFnZScgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG1vdmluZyBwcm9zcGVjdDonLCBlcnJvcik7XG4gICAgICAgICAgc2V0KHsgZXJyb3I6ICdGYWlsZWQgdG8gdXBkYXRlIHByb3NwZWN0IHN0YWdlJyB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFxuICAgICAgdXBkYXRlUHJvc3BlY3RTY29yZTogYXN5bmMgKHByb3NwZWN0SWQsIHNjb3JlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9wcm9zcGVjdHM/aWQ9JHtwcm9zcGVjdElkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgc2NvcmUgfSlcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBsb2NhbCBzdGF0ZVxuICAgICAgICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICAgICAgcHJvc3BlY3RzOiBzdGF0ZS5wcm9zcGVjdHMubWFwKHAgPT5cbiAgICAgICAgICAgICAgICBwLmlkID09PSBwcm9zcGVjdElkXG4gICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgICAgICAgICAgIHF1YWxpZmljYXRpb25TY29yZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucC5xdWFsaWZpY2F0aW9uU2NvcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbDogc2NvcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFsaWZpY2F0aW9uTGV2ZWw6IHNjb3JlID4gNzAgPyAnaGlnaCcgOiBzY29yZSA+IDQwID8gJ21lZGl1bScgOiAnbG93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICA6IHBcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXQoeyBlcnJvcjogcmVzdWx0LmVycm9yIHx8ICdGYWlsZWQgdG8gdXBkYXRlIHByb3NwZWN0IHNjb3JlJyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgcHJvc3BlY3Qgc2NvcmU6JywgZXJyb3IpO1xuICAgICAgICAgIHNldCh7IGVycm9yOiAnRmFpbGVkIHRvIHVwZGF0ZSBwcm9zcGVjdCBzY29yZScgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcbiAgICAgIGFkZFByb3NwZWN0OiBhc3luYyAocHJvc3BlY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3Byb3NwZWN0cycsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIGJ1c2luZXNzX25hbWU6IHByb3NwZWN0LmJ1c2luZXNzLm5hbWUsXG4gICAgICAgICAgICAgIGluZHVzdHJ5OiBwcm9zcGVjdC5idXNpbmVzcy5pbmR1c3RyeSxcbiAgICAgICAgICAgICAgbG9jYXRpb246IGAke3Byb3NwZWN0LmJ1c2luZXNzLmxvY2F0aW9uLmNpdHl9LCAke3Byb3NwZWN0LmJ1c2luZXNzLmxvY2F0aW9uLnN0YXRlfWAsXG4gICAgICAgICAgICAgIGNvbnRhY3RfbmFtZTogcHJvc3BlY3QuY29udGFjdC5wcmltYXJ5Q29udGFjdCxcbiAgICAgICAgICAgICAgY29udGFjdF9lbWFpbDogcHJvc3BlY3QuY29udGFjdC5lbWFpbCxcbiAgICAgICAgICAgICAgY29udGFjdF9waG9uZTogcHJvc3BlY3QuY29udGFjdC5waG9uZSxcbiAgICAgICAgICAgICAgd2Vic2l0ZTogcHJvc3BlY3QuYnVzaW5lc3Mud2Vic2l0ZSxcbiAgICAgICAgICAgICAgdGVtcGVyYXR1cmU6IHByb3NwZWN0LnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICBwaXBlbGluZV9zdGFnZTogcHJvc3BlY3QucGlwZWxpbmVTdGFnZSxcbiAgICAgICAgICAgICAgc2NvcmU6IHByb3NwZWN0LnF1YWxpZmljYXRpb25TY29yZS50b3RhbCxcbiAgICAgICAgICAgICAgbm90ZXM6IHByb3NwZWN0Lm5vdGVzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgY29uc3QgaVByb3NwZWN0ID0gY29udmVydFRvSVByb3NwZWN0KHJlc3VsdC5kYXRhKTtcbiAgICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7IHByb3NwZWN0czogWy4uLnN0YXRlLnByb3NwZWN0cywgaVByb3NwZWN0XSB9KSk7XG5cbiAgICAgICAgICAgIGdldCgpLmFkZE5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogYFByb3NwZWN0ICR7aVByb3NwZWN0LmJ1c2luZXNzLm5hbWV9IGFkZGVkIHN1Y2Nlc3NmdWxseWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXQoeyBlcnJvcjogcmVzdWx0LmVycm9yIHx8ICdGYWlsZWQgdG8gYWRkIHByb3NwZWN0JyB9KTtcbiAgICAgICAgICAgIGdldCgpLmFkZE5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3VsdC5lcnJvciB8fCAnRmFpbGVkIHRvIGFkZCBwcm9zcGVjdCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgcHJvc3BlY3Q6JywgZXJyb3IpO1xuICAgICAgICAgIHNldCh7IGVycm9yOiAnRmFpbGVkIHRvIGFkZCBwcm9zcGVjdCcgfSk7XG4gICAgICAgICAgZ2V0KCkuYWRkTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIGFkZCBwcm9zcGVjdCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdXBkYXRlUHJvc3BlY3Q6IGFzeW5jIChwcm9zcGVjdElkLCB1cGRhdGVzKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9wcm9zcGVjdHM/aWQ9JHtwcm9zcGVjdElkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZXMpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkSVByb3NwZWN0ID0gY29udmVydFRvSVByb3NwZWN0KHJlc3VsdC5kYXRhKTtcbiAgICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgICAgIHByb3NwZWN0czogc3RhdGUucHJvc3BlY3RzLm1hcChwID0+XG4gICAgICAgICAgICAgICAgcC5pZCA9PT0gcHJvc3BlY3RJZCA/IHVwZGF0ZWRJUHJvc3BlY3QgOiBwXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgZ2V0KCkuYWRkTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBgUHJvc3BlY3QgJHt1cGRhdGVkSVByb3NwZWN0LmJ1c2luZXNzLm5hbWV9IHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5YFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldCh7IGVycm9yOiByZXN1bHQuZXJyb3IgfHwgJ0ZhaWxlZCB0byB1cGRhdGUgcHJvc3BlY3QnIH0pO1xuICAgICAgICAgICAgZ2V0KCkuYWRkTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogcmVzdWx0LmVycm9yIHx8ICdGYWlsZWQgdG8gdXBkYXRlIHByb3NwZWN0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHByb3NwZWN0OicsIGVycm9yKTtcbiAgICAgICAgICBzZXQoeyBlcnJvcjogJ0ZhaWxlZCB0byB1cGRhdGUgcHJvc3BlY3QnIH0pO1xuICAgICAgICAgIGdldCgpLmFkZE5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byB1cGRhdGUgcHJvc3BlY3QnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcbiAgICAgIGRlbGV0ZVByb3NwZWN0OiBhc3luYyAocHJvc3BlY3RJZCkgPT4ge1xuICAgICAgICAvLyBOb3RlOiBOZWVkcyBkZWxldGUgaW1wbGVtZW50YXRpb24gaW4gc3VwYWJhc2VIZWxwZXJzXG4gICAgICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgcHJvc3BlY3RzOiBzdGF0ZS5wcm9zcGVjdHMuZmlsdGVyKHAgPT4gcC5pZCAhPT0gcHJvc3BlY3RJZCksXG4gICAgICAgICAgc2VsZWN0ZWRQcm9zcGVjdDogc3RhdGUuc2VsZWN0ZWRQcm9zcGVjdD8uaWQgPT09IHByb3NwZWN0SWQgPyBudWxsIDogc3RhdGUuc2VsZWN0ZWRQcm9zcGVjdFxuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgXG4gICAgICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvbiBtYW5hZ2VtZW50XG4gICAgICBjb25uZWN0V2ViU29ja2V0OiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIGlmIChzdGF0ZS5zb2NrZXQ/LmNvbm5lY3RlZCB8fCBzdGF0ZS53c0Nvbm5lY3RpbmcpIHJldHVybjtcblxuICAgICAgICBzZXQoeyB3c0Nvbm5lY3Rpbmc6IHRydWUsIGVycm9yOiBudWxsIH0pO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc29ja2V0ID0gaW8oJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMScsIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydHM6IFsnd2Vic29ja2V0J10sXG4gICAgICAgICAgICB0aW1lb3V0OiA1MDAwLFxuICAgICAgICAgICAgZm9yY2VOZXc6IHRydWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXZWJTb2NrZXQgY29ubmVjdGVkIHRvIHByb3NwZWN0IHVwZGF0ZXMnKTtcbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgICAgd3NDb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHdzQ29ubmVjdGluZzogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGNoYW5nZXMgYXV0b21hdGljYWxseSBvbiBjb25uZWN0XG4gICAgICAgICAgICBnZXQoKS5zdWJzY3JpYmVUb0NoYW5nZXMoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHNvY2tldC5vbignZGlzY29ubmVjdCcsIChyZWFzb24pID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXZWJTb2NrZXQgZGlzY29ubmVjdGVkOicsIHJlYXNvbik7XG4gICAgICAgICAgICBzZXQoeyB3c0Nvbm5lY3RlZDogZmFsc2UgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzb2NrZXQub24oJ2Nvbm5lY3RfZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1dlYlNvY2tldCBjb25uZWN0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgIHdzQ29ubmVjdGluZzogZmFsc2UsXG4gICAgICAgICAgICAgIHdzQ29ubmVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6ICdGYWlsZWQgdG8gY29ubmVjdCB0byByZWFsLXRpbWUgdXBkYXRlcydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgc2V0KHsgc29ja2V0IH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgV2ViU29ja2V0IGNvbm5lY3Rpb246JywgZXJyb3IpO1xuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICB3c0Nvbm5lY3Rpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdGYWlsZWQgdG8gaW5pdGlhbGl6ZSByZWFsLXRpbWUgdXBkYXRlcydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdFdlYlNvY2tldDogKCkgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICBpZiAoc3RhdGUuc29ja2V0KSB7XG4gICAgICAgICAgc3RhdGUuc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgc29ja2V0OiBudWxsLFxuICAgICAgICAgICAgd3NDb25uZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgd3NDb25uZWN0aW5nOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBSZWFsLXRpbWUgZXZlbnQgc3Vic2NyaXB0aW9uc1xuICAgICAgc3Vic2NyaWJlVG9DaGFuZ2VzOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIGlmICghc3RhdGUuc29ja2V0KSByZXR1cm47XG5cbiAgICAgICAgLy8gTGlzdGVuIGZvciBwcm9zcGVjdCB1cGRhdGVzXG4gICAgICAgIHN0YXRlLnNvY2tldC5vbigncHJvc3BlY3Q6dXBkYXRlZCcsIChkYXRhKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9zcGVjdElkLCB1cGRhdGVzIH0gPSBkYXRhO1xuICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgICBwcm9zcGVjdHM6IHN0YXRlLnByb3NwZWN0cy5tYXAocCA9PlxuICAgICAgICAgICAgICBwLmlkID09PSBwcm9zcGVjdElkID8geyAuLi5wLCAuLi51cGRhdGVzIH0gOiBwXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgZ2V0KCkuYWRkTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICdpbmZvJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBQcm9zcGVjdCAke3VwZGF0ZXMuYnVzaW5lc3M/Lm5hbWUgfHwgcHJvc3BlY3RJZH0gdXBkYXRlZGBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTGlzdGVuIGZvciBwcm9zcGVjdCBzdGFnZSBjaGFuZ2VzXG4gICAgICAgIHN0YXRlLnNvY2tldC5vbigncHJvc3BlY3Q6c3RhZ2VfY2hhbmdlZCcsIChkYXRhKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9zcGVjdElkLCBuZXdTdGFnZSwgb2xkU3RhZ2UgfSA9IGRhdGE7XG4gICAgICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICAgIHByb3NwZWN0czogc3RhdGUucHJvc3BlY3RzLm1hcChwID0+XG4gICAgICAgICAgICAgIHAuaWQgPT09IHByb3NwZWN0SWQgPyB7IC4uLnAsIHBpcGVsaW5lU3RhZ2U6IG5ld1N0YWdlIH0gOiBwXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgZ2V0KCkuYWRkTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBQcm9zcGVjdCBtb3ZlZCBmcm9tICR7b2xkU3RhZ2V9IHRvICR7bmV3U3RhZ2V9YFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBMaXN0ZW4gZm9yIG5ldyBwcm9zcGVjdHNcbiAgICAgICAgc3RhdGUuc29ja2V0Lm9uKCdwcm9zcGVjdDpjcmVhdGVkJywgKGRhdGEpID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdQcm9zcGVjdCA9IGNvbnZlcnRUb0lQcm9zcGVjdChkYXRhLnByb3NwZWN0KTtcbiAgICAgICAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgcHJvc3BlY3RzOiBbLi4uc3RhdGUucHJvc3BlY3RzLCBuZXdQcm9zcGVjdF1cbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBnZXQoKS5hZGROb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgbWVzc2FnZTogYE5ldyBwcm9zcGVjdCBhZGRlZDogJHtuZXdQcm9zcGVjdC5idXNpbmVzcy5uYW1lfWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTGlzdGVuIGZvciByZXNlYXJjaCBwcm9ncmVzc1xuICAgICAgICBzdGF0ZS5zb2NrZXQub24oJ3Jlc2VhcmNoOnByb2dyZXNzJywgKGRhdGEpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb3NwZWN0SWQsIHN0YWdlLCBwcm9ncmVzcyB9ID0gZGF0YTtcblxuICAgICAgICAgIGdldCgpLmFkZE5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICB0eXBlOiAnaW5mbycsXG4gICAgICAgICAgICBtZXNzYWdlOiBgUmVzZWFyY2ggJHtzdGFnZX0gKCR7cHJvZ3Jlc3N9JSkgZm9yIHByb3NwZWN0ICR7cHJvc3BlY3RJZH1gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN0YXRlLnNvY2tldC5vbigncmVzZWFyY2g6Y29tcGxldGVkJywgKGRhdGEpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb3NwZWN0SWQsIHN1Y2Nlc3MgfSA9IGRhdGE7XG5cbiAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgLy8gUmVmcmVzaCBwcm9zcGVjdCBkYXRhXG4gICAgICAgICAgICBnZXQoKS5mZXRjaFByb3NwZWN0cygpO1xuXG4gICAgICAgICAgICBnZXQoKS5hZGROb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGBSZXNlYXJjaCBjb21wbGV0ZWQgZm9yIHByb3NwZWN0ICR7cHJvc3BlY3RJZH1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN5c3RlbSBhbGVydHNcbiAgICAgICAgc3RhdGUuc29ja2V0Lm9uKCdzeXN0ZW06YWxlcnQnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgbGV2ZWwsIG1lc3NhZ2UgfSA9IGRhdGE7XG4gICAgICAgICAgZ2V0KCkuYWRkTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6IGxldmVsID09PSAnZXJyb3InID8gJ2Vycm9yJyA6IGxldmVsID09PSAnd2FybmluZycgPyAnd2FybmluZycgOiAnaW5mbycsXG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdTdWJzY3JpYmVkIHRvIHJlYWwtdGltZSBwcm9zcGVjdCB1cGRhdGVzJyk7XG4gICAgICB9LFxuXG4gICAgICB1bnN1YnNjcmliZUZyb21DaGFuZ2VzOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIGlmIChzdGF0ZS5zb2NrZXQpIHtcbiAgICAgICAgICBzdGF0ZS5zb2NrZXQub2ZmKCdwcm9zcGVjdDp1cGRhdGVkJyk7XG4gICAgICAgICAgc3RhdGUuc29ja2V0Lm9mZigncHJvc3BlY3Q6c3RhZ2VfY2hhbmdlZCcpO1xuICAgICAgICAgIHN0YXRlLnNvY2tldC5vZmYoJ3Byb3NwZWN0OmNyZWF0ZWQnKTtcbiAgICAgICAgICBzdGF0ZS5zb2NrZXQub2ZmKCdyZXNlYXJjaDpwcm9ncmVzcycpO1xuICAgICAgICAgIHN0YXRlLnNvY2tldC5vZmYoJ3Jlc2VhcmNoOmNvbXBsZXRlZCcpO1xuICAgICAgICAgIHN0YXRlLnNvY2tldC5vZmYoJ3N5c3RlbTphbGVydCcpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdVbnN1YnNjcmliZWQgZnJvbSByZWFsLXRpbWUgdXBkYXRlcycpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXG4gICAgICAvLyBSZXNlYXJjaFxuICAgICAgcmVzZWFyY2hRdWV1ZTogW10sXG4gICAgICBhZGRUb1Jlc2VhcmNoUXVldWU6IChwcm9zcGVjdElkKSA9PiBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICByZXNlYXJjaFF1ZXVlOiBbLi4uc3RhdGUucmVzZWFyY2hRdWV1ZSwgcHJvc3BlY3RJZF1cbiAgICAgIH0pKSxcbiAgICAgIHJlbW92ZUZyb21SZXNlYXJjaFF1ZXVlOiAocHJvc3BlY3RJZCkgPT4gc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgcmVzZWFyY2hRdWV1ZTogc3RhdGUucmVzZWFyY2hRdWV1ZS5maWx0ZXIoaWQgPT4gaWQgIT09IHByb3NwZWN0SWQpXG4gICAgICB9KSksXG4gICAgICBpc1Jlc2VhcmNoaW5nOiBmYWxzZSxcbiAgICAgIHNldElzUmVzZWFyY2hpbmc6IChyZXNlYXJjaGluZykgPT4gc2V0KHsgaXNSZXNlYXJjaGluZzogcmVzZWFyY2hpbmcgfSksXG5cbiAgICAgIC8vIE5vdGlmaWNhdGlvbnNcbiAgICAgIG5vdGlmaWNhdGlvbnM6IFtdLFxuICAgICAgYWRkTm90aWZpY2F0aW9uOiAobm90aWZpY2F0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gYG5vdGlmaWNhdGlvbi0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG4gICAgICAgIGNvbnN0IG5ld05vdGlmaWNhdGlvbiA9IHtcbiAgICAgICAgICAuLi5ub3RpZmljYXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXG4gICAgICAgIH07XG5cbiAgICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICBub3RpZmljYXRpb25zOiBbLi4uc3RhdGUubm90aWZpY2F0aW9ucywgbmV3Tm90aWZpY2F0aW9uXVxuICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gQXV0by1yZW1vdmUgaW5mbyBub3RpZmljYXRpb25zIGFmdGVyIDUgc2Vjb25kc1xuICAgICAgICBpZiAobm90aWZpY2F0aW9uLnR5cGUgPT09ICdpbmZvJykge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZ2V0KCkucmVtb3ZlTm90aWZpY2F0aW9uKGlkKTtcbiAgICAgICAgICB9LCA1MDAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChub3RpZmljYXRpb24udHlwZSA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBnZXQoKS5yZW1vdmVOb3RpZmljYXRpb24oaWQpO1xuICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICByZW1vdmVOb3RpZmljYXRpb246IChpZCkgPT4ge1xuICAgICAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgIG5vdGlmaWNhdGlvbnM6IHN0YXRlLm5vdGlmaWNhdGlvbnMuZmlsdGVyKG4gPT4gbi5pZCAhPT0gaWQpXG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIC8vIENvbXB1dGVkIHZhbHVlc1xuICAgICAgZ2V0RmlsdGVyZWRQcm9zcGVjdHM6ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICAgICAgbGV0IGZpbHRlcmVkID0gWy4uLnN0YXRlLnByb3NwZWN0c107XG4gICAgICAgIFxuICAgICAgICAvLyBTdGFnZSBmaWx0ZXJcbiAgICAgICAgaWYgKHN0YXRlLnN0YWdlRmlsdGVyICE9PSAnYWxsJykge1xuICAgICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQuZmlsdGVyKHAgPT4gcC5waXBlbGluZVN0YWdlID09PSBzdGF0ZS5zdGFnZUZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEluZHVzdHJ5IGZpbHRlclxuICAgICAgICBpZiAoc3RhdGUuaW5kdXN0cnlGaWx0ZXIgIT09ICdhbGwnKSB7XG4gICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIocCA9PiBwLmJ1c2luZXNzLmluZHVzdHJ5ID09PSBzdGF0ZS5pbmR1c3RyeUZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNlYXJjaFxuICAgICAgICBpZiAoc3RhdGUuc2VhcmNoUXVlcnkpIHtcbiAgICAgICAgICBjb25zdCBxdWVyeSA9IHN0YXRlLnNlYXJjaFF1ZXJ5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIocCA9PiBcbiAgICAgICAgICAgIHAuYnVzaW5lc3MubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5KSB8fFxuICAgICAgICAgICAgcC5jb250YWN0LnByaW1hcnlDb250YWN0LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnkpIHx8XG4gICAgICAgICAgICBwLmJ1c2luZXNzLmxvY2F0aW9uLmNpdHkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgICB9LFxuICAgICAgXG4gICAgICBnZXRTdGFnZUNvdW50OiAoc3RhZ2UpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICAgICAgaWYgKHN0YWdlID09PSAnY29sZCcpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUucHJvc3BlY3RzLmZpbHRlcihwID0+IHAudGVtcGVyYXR1cmUgPT09ICdjb2xkJykubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZS5wcm9zcGVjdHMuZmlsdGVyKHAgPT4gcC5waXBlbGluZVN0YWdlID09PSBzdGFnZSkubGVuZ3RoO1xuICAgICAgfSxcbiAgICB9KSxcbiAgICB7XG4gICAgICBuYW1lOiAncGlwZWxpbmUtc3RvcmUnXG4gICAgfVxuICApXG4pOyJdLCJuYW1lcyI6WyJjcmVhdGUiLCJkZXZ0b29scyIsImlvIiwiY29udmVydFRvSVByb3NwZWN0IiwiZGJQcm9zcGVjdCIsImlkIiwiYnVzaW5lc3MiLCJuYW1lIiwiYnVzaW5lc3NfbmFtZSIsImluZHVzdHJ5IiwibG9jYXRpb24iLCJhZGRyZXNzIiwiY2l0eSIsInNwbGl0IiwidHJpbSIsInN0YXRlIiwiemlwQ29kZSIsImNvdW50cnkiLCJjb29yZGluYXRlcyIsImxhdCIsImxuZyIsIndlYnNpdGUiLCJkZXNjcmlwdGlvbiIsInNpemUiLCJjYXRlZ29yeSIsImVtcGxveWVlQ291bnQiLCJlc3RpbWF0ZWRSZXZlbnVlIiwiZGlnaXRhbFByZXNlbmNlIiwiaGFzV2Vic2l0ZSIsImhhc0dvb2dsZUJ1c2luZXNzIiwiaGFzU29jaWFsTWVkaWEiLCJoYXNPbmxpbmVSZXZpZXdzIiwid2Vic2l0ZVVybCIsInVuZGVmaW5lZCIsImNvbnRhY3QiLCJwcmltYXJ5Q29udGFjdCIsImNvbnRhY3RfbmFtZSIsImNvbnRhY3RUaXRsZSIsImVtYWlsIiwiY29udGFjdF9lbWFpbCIsInBob25lIiwiY29udGFjdF9waG9uZSIsImRlY2lzaW9uTWFrZXIiLCJzb2NpYWxQcm9maWxlcyIsInBpcGVsaW5lU3RhZ2UiLCJwaXBlbGluZV9zdGFnZSIsInF1YWxpZmljYXRpb25TY29yZSIsInRvdGFsIiwic2NvcmUiLCJicmVha2Rvd24iLCJidXNpbmVzc1NpemUiLCJjb21wZXRpdG9yR2FwcyIsInJldmVudWVJbmRpY2F0b3JzIiwicXVhbGlmaWNhdGlvbkxldmVsIiwibGFzdFVwZGF0ZWQiLCJEYXRlIiwidXBkYXRlZF9hdCIsInJlc2VhcmNoUGFzc2VzIiwicGFzc051bWJlciIsInR5cGUiLCJzdGF0dXMiLCJjb21wbGV0ZWRBdCIsImNyZWF0ZWRfYXQiLCJkYXRhQ29sbGVjdGVkIiwicmV0cnlDb3VudCIsInNvdXJjZSIsImFwaSIsImRhdGFDb25maWRlbmNlIiwiYnVzaW5lc3NJbnNpZ2h0cyIsInBhaW5Qb2ludHMiLCJjb21wZXRpdGl2ZUFkdmFudGFnZXMiLCJ0YWdzIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwidXNlUGlwZWxpbmVTdG9yZVdpdGhTdXBhYmFzZSIsInNldCIsImdldCIsInByb3NwZWN0cyIsInNlbGVjdGVkUHJvc3BlY3QiLCJzZXRTZWxlY3RlZFByb3NwZWN0IiwicHJvc3BlY3QiLCJpc0xvYWRpbmciLCJlcnJvciIsInNvY2tldCIsIndzQ29ubmVjdGVkIiwid3NDb25uZWN0aW5nIiwic3RhZ2VGaWx0ZXIiLCJzZXRTdGFnZUZpbHRlciIsInN0YWdlIiwiaW5kdXN0cnlGaWx0ZXIiLCJzZXRJbmR1c3RyeUZpbHRlciIsInNlYXJjaFF1ZXJ5Iiwic2V0U2VhcmNoUXVlcnkiLCJxdWVyeSIsImZldGNoUHJvc3BlY3RzIiwicmVzcG9uc2UiLCJmZXRjaCIsInJlc3VsdCIsImpzb24iLCJzdWNjZXNzIiwiZGF0YSIsIm1hcCIsImNvbnNvbGUiLCJtb3ZlUHJvc3BlY3QiLCJwcm9zcGVjdElkIiwibmV3U3RhZ2UiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwIiwidXBkYXRlUHJvc3BlY3RTY29yZSIsImFkZFByb3NwZWN0IiwidGVtcGVyYXR1cmUiLCJub3RlcyIsImlQcm9zcGVjdCIsImFkZE5vdGlmaWNhdGlvbiIsIm1lc3NhZ2UiLCJ1cGRhdGVQcm9zcGVjdCIsInVwZGF0ZXMiLCJ1cGRhdGVkSVByb3NwZWN0IiwiZGVsZXRlUHJvc3BlY3QiLCJmaWx0ZXIiLCJjb25uZWN0V2ViU29ja2V0IiwiY29ubmVjdGVkIiwidHJhbnNwb3J0cyIsInRpbWVvdXQiLCJmb3JjZU5ldyIsIm9uIiwibG9nIiwic3Vic2NyaWJlVG9DaGFuZ2VzIiwicmVhc29uIiwiZGlzY29ubmVjdFdlYlNvY2tldCIsImRpc2Nvbm5lY3QiLCJvbGRTdGFnZSIsIm5ld1Byb3NwZWN0IiwicHJvZ3Jlc3MiLCJsZXZlbCIsInVuc3Vic2NyaWJlRnJvbUNoYW5nZXMiLCJvZmYiLCJyZXNlYXJjaFF1ZXVlIiwiYWRkVG9SZXNlYXJjaFF1ZXVlIiwicmVtb3ZlRnJvbVJlc2VhcmNoUXVldWUiLCJpc1Jlc2VhcmNoaW5nIiwic2V0SXNSZXNlYXJjaGluZyIsInJlc2VhcmNoaW5nIiwibm90aWZpY2F0aW9ucyIsIm5vdGlmaWNhdGlvbiIsIk1hdGgiLCJub3ciLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsIm5ld05vdGlmaWNhdGlvbiIsInRpbWVzdGFtcCIsInNldFRpbWVvdXQiLCJyZW1vdmVOb3RpZmljYXRpb24iLCJuIiwiZ2V0RmlsdGVyZWRQcm9zcGVjdHMiLCJmaWx0ZXJlZCIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJnZXRTdGFnZUNvdW50IiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./stores/usePipelineStoreWithSupabase.ts\n"));

/***/ })

});