"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./stores/usePipelineStoreWithSupabase.ts":
/*!************************************************!*\
  !*** ./stores/usePipelineStoreWithSupabase.ts ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   usePipelineStoreWithSupabase: function() { return /* binding */ usePipelineStoreWithSupabase; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! socket.io-client */ \"(app-pages-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n\n\n\n// Convert database prospect to IProspect\nconst convertToIProspect = (dbProspect)=>{\n    var _dbProspect_location_split_, _dbProspect_location_split_1;\n    return {\n        id: dbProspect.id,\n        business: {\n            name: dbProspect.business_name,\n            industry: dbProspect.industry,\n            location: {\n                address: \"\",\n                city: ((_dbProspect_location_split_ = dbProspect.location.split(\",\")[0]) === null || _dbProspect_location_split_ === void 0 ? void 0 : _dbProspect_location_split_.trim()) || \"\",\n                state: ((_dbProspect_location_split_1 = dbProspect.location.split(\",\")[1]) === null || _dbProspect_location_split_1 === void 0 ? void 0 : _dbProspect_location_split_1.trim()) || \"\",\n                zipCode: \"\",\n                country: \"USA\",\n                coordinates: {\n                    lat: 0,\n                    lng: 0\n                }\n            },\n            website: dbProspect.website || \"\",\n            description: \"\",\n            size: {\n                category: \"small\",\n                employeeCount: 10,\n                estimatedRevenue: 500000\n            },\n            digitalPresence: {\n                hasWebsite: !!dbProspect.website,\n                hasGoogleBusiness: true,\n                hasSocialMedia: false,\n                hasOnlineReviews: false,\n                websiteUrl: dbProspect.website || undefined\n            }\n        },\n        contact: {\n            primaryContact: dbProspect.contact_name || \"\",\n            contactTitle: \"Owner\",\n            email: dbProspect.contact_email || \"\",\n            phone: dbProspect.contact_phone || \"\",\n            website: dbProspect.website || \"\",\n            decisionMaker: \"Yes\",\n            socialProfiles: {}\n        },\n        pipelineStage: dbProspect.pipeline_stage,\n        qualificationScore: {\n            total: dbProspect.score,\n            breakdown: {\n                businessSize: 15,\n                digitalPresence: 20,\n                competitorGaps: 15,\n                location: 10,\n                industry: 5,\n                revenueIndicators: 5\n            },\n            qualificationLevel: dbProspect.score > 70 ? \"high\" : dbProspect.score > 40 ? \"medium\" : \"low\",\n            lastUpdated: new Date(dbProspect.updated_at)\n        },\n        researchPasses: [\n            {\n                passNumber: 1,\n                type: \"google_maps\",\n                status: \"completed\",\n                completedAt: new Date(dbProspect.created_at),\n                dataCollected: {},\n                retryCount: 0,\n                source: {\n                    api: \"Google Maps API\"\n                }\n            },\n            {\n                passNumber: 2,\n                type: \"firecrawl\",\n                status: \"completed\",\n                completedAt: new Date(dbProspect.created_at),\n                dataCollected: {},\n                retryCount: 0,\n                source: {\n                    api: \"Firecrawl\"\n                }\n            }\n        ],\n        dataConfidence: 85,\n        businessInsights: {\n            painPoints: [\n                \"Limited online presence\"\n            ],\n            competitiveAdvantages: [\n                \"Strong local reputation\"\n            ]\n        },\n        tags: [\n            \"prospect\",\n            dbProspect.industry\n        ],\n        createdAt: new Date(dbProspect.created_at),\n        updatedAt: new Date(dbProspect.updated_at)\n    };\n};\nconst usePipelineStoreWithSupabase = (0,zustand__WEBPACK_IMPORTED_MODULE_1__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_2__.devtools)((set, get)=>({\n        // Prospects\n        prospects: [],\n        selectedProspect: null,\n        setSelectedProspect: (prospect)=>set({\n                selectedProspect: prospect\n            }),\n        // Loading states\n        isLoading: false,\n        error: null,\n        // WebSocket connection\n        socket: null,\n        wsConnected: false,\n        wsConnecting: false,\n        // Filtering\n        stageFilter: \"all\",\n        setStageFilter: (stage)=>set({\n                stageFilter: stage\n            }),\n        industryFilter: \"all\",\n        setIndustryFilter: (industry)=>set({\n                industryFilter: industry\n            }),\n        searchQuery: \"\",\n        setSearchQuery: (query)=>set({\n                searchQuery: query\n            }),\n        // Actions\n        fetchProspects: async ()=>{\n            set({\n                isLoading: true,\n                error: null\n            });\n            try {\n                const response = await fetch(\"/api/prospects\");\n                const result = await response.json();\n                if (result.success) {\n                    const prospects = result.data.map(convertToIProspect);\n                    set({\n                        prospects,\n                        isLoading: false\n                    });\n                } else {\n                    set({\n                        error: result.error || \"Failed to fetch prospects\",\n                        isLoading: false\n                    });\n                }\n            } catch (error) {\n                set({\n                    error: \"Failed to fetch prospects\",\n                    isLoading: false\n                });\n                console.error(\"Error fetching prospects:\", error);\n            }\n        },\n        moveProspect: async (prospectId, newStage)=>{\n            try {\n                const response = await fetch(\"/api/prospects?id=\".concat(prospectId), {\n                    method: \"PUT\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        pipeline_stage: newStage\n                    })\n                });\n                const result = await response.json();\n                if (result.success) {\n                    // Update local state optimistically\n                    set((state)=>({\n                            prospects: state.prospects.map((p)=>p.id === prospectId ? {\n                                    ...p,\n                                    pipelineStage: newStage\n                                } : p)\n                        }));\n                } else {\n                    set({\n                        error: result.error || \"Failed to update prospect stage\"\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error moving prospect:\", error);\n                set({\n                    error: \"Failed to update prospect stage\"\n                });\n            }\n        },\n        updateProspectScore: async (prospectId, score)=>{\n            try {\n                const response = await fetch(\"/api/prospects?id=\".concat(prospectId), {\n                    method: \"PUT\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        score\n                    })\n                });\n                const result = await response.json();\n                if (result.success) {\n                    // Update local state\n                    set((state)=>({\n                            prospects: state.prospects.map((p)=>p.id === prospectId ? {\n                                    ...p,\n                                    qualificationScore: {\n                                        ...p.qualificationScore,\n                                        total: score,\n                                        qualificationLevel: score > 70 ? \"high\" : score > 40 ? \"medium\" : \"low\",\n                                        lastUpdated: new Date()\n                                    }\n                                } : p)\n                        }));\n                } else {\n                    set({\n                        error: result.error || \"Failed to update prospect score\"\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error updating prospect score:\", error);\n                set({\n                    error: \"Failed to update prospect score\"\n                });\n            }\n        },\n        addProspect: async (prospect)=>{\n            try {\n                const response = await fetch(\"/api/prospects\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        business_name: prospect.business.name,\n                        industry: prospect.business.industry,\n                        location: \"\".concat(prospect.business.location.city, \", \").concat(prospect.business.location.state),\n                        contact_name: prospect.contact.primaryContact,\n                        contact_email: prospect.contact.email,\n                        contact_phone: prospect.contact.phone,\n                        website: prospect.business.website,\n                        temperature: prospect.temperature,\n                        pipeline_stage: prospect.pipelineStage,\n                        score: prospect.qualificationScore.total,\n                        notes: prospect.notes\n                    })\n                });\n                const result = await response.json();\n                if (result.success) {\n                    const iProspect = convertToIProspect(result.data);\n                    set((state)=>({\n                            prospects: [\n                                ...state.prospects,\n                                iProspect\n                            ]\n                        }));\n                    get().addNotification({\n                        type: \"success\",\n                        message: \"Prospect \".concat(iProspect.business.name, \" added successfully\")\n                    });\n                } else {\n                    set({\n                        error: result.error || \"Failed to add prospect\"\n                    });\n                    get().addNotification({\n                        type: \"error\",\n                        message: result.error || \"Failed to add prospect\"\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error adding prospect:\", error);\n                set({\n                    error: \"Failed to add prospect\"\n                });\n                get().addNotification({\n                    type: \"error\",\n                    message: \"Failed to add prospect\"\n                });\n            }\n        },\n        updateProspect: async (prospectId, updates)=>{\n            try {\n                const response = await fetch(\"/api/prospects?id=\".concat(prospectId), {\n                    method: \"PUT\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify(updates)\n                });\n                const result = await response.json();\n                if (result.success) {\n                    const updatedIProspect = convertToIProspect(result.data);\n                    set((state)=>({\n                            prospects: state.prospects.map((p)=>p.id === prospectId ? updatedIProspect : p)\n                        }));\n                    get().addNotification({\n                        type: \"success\",\n                        message: \"Prospect \".concat(updatedIProspect.business.name, \" updated successfully\")\n                    });\n                } else {\n                    set({\n                        error: result.error || \"Failed to update prospect\"\n                    });\n                    get().addNotification({\n                        type: \"error\",\n                        message: result.error || \"Failed to update prospect\"\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error updating prospect:\", error);\n                set({\n                    error: \"Failed to update prospect\"\n                });\n                get().addNotification({\n                    type: \"error\",\n                    message: \"Failed to update prospect\"\n                });\n            }\n        },\n        deleteProspect: async (prospectId)=>{\n            try {\n                const prospect = get().prospects.find((p)=>p.id === prospectId);\n                const response = await fetch(\"/api/prospects?id=\".concat(prospectId), {\n                    method: \"DELETE\"\n                });\n                const result = await response.json();\n                if (result.success) {\n                    set((state)=>{\n                        var _state_selectedProspect;\n                        return {\n                            prospects: state.prospects.filter((p)=>p.id !== prospectId),\n                            selectedProspect: ((_state_selectedProspect = state.selectedProspect) === null || _state_selectedProspect === void 0 ? void 0 : _state_selectedProspect.id) === prospectId ? null : state.selectedProspect\n                        };\n                    });\n                    get().addNotification({\n                        type: \"success\",\n                        message: \"Prospect \".concat((prospect === null || prospect === void 0 ? void 0 : prospect.business.name) || \"deleted\", \" removed successfully\")\n                    });\n                } else {\n                    set({\n                        error: result.error || \"Failed to delete prospect\"\n                    });\n                    get().addNotification({\n                        type: \"error\",\n                        message: result.error || \"Failed to delete prospect\"\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error deleting prospect:\", error);\n                set({\n                    error: \"Failed to delete prospect\"\n                });\n                get().addNotification({\n                    type: \"error\",\n                    message: \"Failed to delete prospect\"\n                });\n            }\n        },\n        // WebSocket connection management\n        connectWebSocket: ()=>{\n            var _state_socket;\n            const state = get();\n            if (((_state_socket = state.socket) === null || _state_socket === void 0 ? void 0 : _state_socket.connected) || state.wsConnecting) return;\n            set({\n                wsConnecting: true,\n                error: null\n            });\n            try {\n                const socket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_0__.io)(\"http://localhost:3001\", {\n                    transports: [\n                        \"websocket\"\n                    ],\n                    timeout: 5000,\n                    forceNew: true\n                });\n                socket.on(\"connect\", ()=>{\n                    console.log(\"WebSocket connected to prospect updates\");\n                    set({\n                        socket,\n                        wsConnected: true,\n                        wsConnecting: false,\n                        error: null\n                    });\n                    // Subscribe to changes automatically on connect\n                    get().subscribeToChanges();\n                });\n                socket.on(\"disconnect\", (reason)=>{\n                    console.log(\"WebSocket disconnected:\", reason);\n                    set({\n                        wsConnected: false\n                    });\n                });\n                socket.on(\"connect_error\", (error)=>{\n                    console.error(\"WebSocket connection error:\", error);\n                    set({\n                        wsConnecting: false,\n                        wsConnected: false,\n                        error: \"Failed to connect to real-time updates\"\n                    });\n                });\n                set({\n                    socket\n                });\n            } catch (error) {\n                console.error(\"Failed to create WebSocket connection:\", error);\n                set({\n                    wsConnecting: false,\n                    error: \"Failed to initialize real-time updates\"\n                });\n            }\n        },\n        disconnectWebSocket: ()=>{\n            const state = get();\n            if (state.socket) {\n                state.socket.disconnect();\n                set({\n                    socket: null,\n                    wsConnected: false,\n                    wsConnecting: false\n                });\n            }\n        },\n        // Real-time event subscriptions\n        subscribeToChanges: ()=>{\n            const state = get();\n            if (!state.socket) return;\n            // Listen for prospect updates\n            state.socket.on(\"prospect:updated\", (data)=>{\n                var _updates_business;\n                const { prospectId, updates } = data;\n                set((state)=>({\n                        prospects: state.prospects.map((p)=>p.id === prospectId ? {\n                                ...p,\n                                ...updates\n                            } : p)\n                    }));\n                get().addNotification({\n                    type: \"info\",\n                    message: \"Prospect \".concat(((_updates_business = updates.business) === null || _updates_business === void 0 ? void 0 : _updates_business.name) || prospectId, \" updated\")\n                });\n            });\n            // Listen for prospect stage changes\n            state.socket.on(\"prospect:stage_changed\", (data)=>{\n                const { prospectId, newStage, oldStage } = data;\n                set((state)=>({\n                        prospects: state.prospects.map((p)=>p.id === prospectId ? {\n                                ...p,\n                                pipelineStage: newStage\n                            } : p)\n                    }));\n                get().addNotification({\n                    type: \"success\",\n                    message: \"Prospect moved from \".concat(oldStage, \" to \").concat(newStage)\n                });\n            });\n            // Listen for new prospects\n            state.socket.on(\"prospect:created\", (data)=>{\n                const newProspect = convertToIProspect(data.prospect);\n                set((state)=>({\n                        prospects: [\n                            ...state.prospects,\n                            newProspect\n                        ]\n                    }));\n                get().addNotification({\n                    type: \"success\",\n                    message: \"New prospect added: \".concat(newProspect.business.name)\n                });\n            });\n            // Listen for research progress\n            state.socket.on(\"research:progress\", (data)=>{\n                const { prospectId, stage, progress } = data;\n                get().addNotification({\n                    type: \"info\",\n                    message: \"Research \".concat(stage, \" (\").concat(progress, \"%) for prospect \").concat(prospectId)\n                });\n            });\n            state.socket.on(\"research:completed\", (data)=>{\n                const { prospectId, success } = data;\n                if (success) {\n                    // Refresh prospect data\n                    get().fetchProspects();\n                    get().addNotification({\n                        type: \"success\",\n                        message: \"Research completed for prospect \".concat(prospectId)\n                    });\n                }\n            });\n            // System alerts\n            state.socket.on(\"system:alert\", (data)=>{\n                const { level, message } = data;\n                get().addNotification({\n                    type: level === \"error\" ? \"error\" : level === \"warning\" ? \"warning\" : \"info\",\n                    message\n                });\n            });\n            console.log(\"Subscribed to real-time prospect updates\");\n        },\n        unsubscribeFromChanges: ()=>{\n            const state = get();\n            if (state.socket) {\n                state.socket.off(\"prospect:updated\");\n                state.socket.off(\"prospect:stage_changed\");\n                state.socket.off(\"prospect:created\");\n                state.socket.off(\"research:progress\");\n                state.socket.off(\"research:completed\");\n                state.socket.off(\"system:alert\");\n                console.log(\"Unsubscribed from real-time updates\");\n            }\n        },\n        // Research\n        researchQueue: [],\n        addToResearchQueue: (prospectId)=>set((state)=>({\n                    researchQueue: [\n                        ...state.researchQueue,\n                        prospectId\n                    ]\n                })),\n        removeFromResearchQueue: (prospectId)=>set((state)=>({\n                    researchQueue: state.researchQueue.filter((id)=>id !== prospectId)\n                })),\n        isResearching: false,\n        setIsResearching: (researching)=>set({\n                isResearching: researching\n            }),\n        // Notifications\n        notifications: [],\n        addNotification: (notification)=>{\n            const id = \"notification-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 9));\n            const newNotification = {\n                ...notification,\n                id,\n                timestamp: new Date()\n            };\n            set((state)=>({\n                    notifications: [\n                        ...state.notifications,\n                        newNotification\n                    ]\n                }));\n            // Auto-remove info notifications after 5 seconds\n            if (notification.type === \"info\") {\n                setTimeout(()=>{\n                    get().removeNotification(id);\n                }, 5000);\n            } else if (notification.type === \"success\") {\n                setTimeout(()=>{\n                    get().removeNotification(id);\n                }, 3000);\n            }\n        },\n        removeNotification: (id)=>{\n            set((state)=>({\n                    notifications: state.notifications.filter((n)=>n.id !== id)\n                }));\n        },\n        // Computed values\n        getFilteredProspects: ()=>{\n            const state = get();\n            let filtered = [\n                ...state.prospects\n            ];\n            // Stage filter\n            if (state.stageFilter !== \"all\") {\n                filtered = filtered.filter((p)=>p.pipelineStage === state.stageFilter);\n            }\n            // Industry filter\n            if (state.industryFilter !== \"all\") {\n                filtered = filtered.filter((p)=>p.business.industry === state.industryFilter);\n            }\n            // Search\n            if (state.searchQuery) {\n                const query = state.searchQuery.toLowerCase();\n                filtered = filtered.filter((p)=>p.business.name.toLowerCase().includes(query) || p.contact.primaryContact.toLowerCase().includes(query) || p.business.location.city.toLowerCase().includes(query));\n            }\n            return filtered;\n        },\n        getStageCount: (stage)=>{\n            const state = get();\n            if (stage === \"cold\") {\n                return state.prospects.filter((p)=>p.temperature === \"cold\").length;\n            }\n            return state.prospects.filter((p)=>p.pipelineStage === stage).length;\n        }\n    }), {\n    name: \"pipeline-store\"\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3Jlcy91c2VQaXBlbGluZVN0b3JlV2l0aFN1cGFiYXNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUM7QUFDYTtBQUVBO0FBcUI5Qyx5Q0FBeUM7QUFDekMsTUFBTUcscUJBQXFCLENBQUNDO1FBUWRBLDZCQUNDQTtJQVJiLE9BQU87UUFDTEMsSUFBSUQsV0FBV0MsRUFBRTtRQUNqQkMsVUFBVTtZQUNSQyxNQUFNSCxXQUFXSSxhQUFhO1lBQzlCQyxVQUFVTCxXQUFXSyxRQUFRO1lBQzdCQyxVQUFVO2dCQUNSQyxTQUFTO2dCQUNUQyxNQUFNUixFQUFBQSw4QkFBQUEsV0FBV00sUUFBUSxDQUFDRyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsY0FBakNULGtEQUFBQSw0QkFBbUNVLElBQUksT0FBTTtnQkFDbkRDLE9BQU9YLEVBQUFBLCtCQUFBQSxXQUFXTSxRQUFRLENBQUNHLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxjQUFqQ1QsbURBQUFBLDZCQUFtQ1UsSUFBSSxPQUFNO2dCQUNwREUsU0FBUztnQkFDVEMsU0FBUztnQkFDVEMsYUFBYTtvQkFBRUMsS0FBSztvQkFBR0MsS0FBSztnQkFBRTtZQUNoQztZQUNBQyxTQUFTakIsV0FBV2lCLE9BQU8sSUFBSTtZQUMvQkMsYUFBYTtZQUNiQyxNQUFNO2dCQUNKQyxVQUFVO2dCQUNWQyxlQUFlO2dCQUNmQyxrQkFBa0I7WUFDcEI7WUFDQUMsaUJBQWlCO2dCQUNmQyxZQUFZLENBQUMsQ0FBQ3hCLFdBQVdpQixPQUFPO2dCQUNoQ1EsbUJBQW1CO2dCQUNuQkMsZ0JBQWdCO2dCQUNoQkMsa0JBQWtCO2dCQUNsQkMsWUFBWTVCLFdBQVdpQixPQUFPLElBQUlZO1lBQ3BDO1FBQ0Y7UUFDQUMsU0FBUztZQUNQQyxnQkFBZ0IvQixXQUFXZ0MsWUFBWSxJQUFJO1lBQzNDQyxjQUFjO1lBQ2RDLE9BQU9sQyxXQUFXbUMsYUFBYSxJQUFJO1lBQ25DQyxPQUFPcEMsV0FBV3FD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UTZEO1lBQ2QsSUFBSVksVUFBVSxRQUFRO2dCQUNwQixPQUFPekUsTUFBTThELFNBQVMsQ0FBQytDLE1BQU0sQ0FBQ2IsQ0FBQUEsSUFBS0EsRUFBRUcsV0FBVyxLQUFLLFFBQVFtRCxNQUFNO1lBQ3JFO1lBQ0EsT0FBT3RKLE1BQU04RCxTQUFTLENBQUMrQyxNQUFNLENBQUNiLENBQUFBLElBQUtBLEVBQUVuRSxhQUFhLEtBQUs0QyxPQUFPNkUsTUFBTTtRQUN0RTtJQUNGLElBQ0E7SUFDRTlKLE1BQU07QUFDUixJQUVGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3N0b3Jlcy91c2VQaXBlbGluZVN0b3JlV2l0aFN1cGFiYXNlLnRzPzgzOTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCc7XG5pbXBvcnQgeyBkZXZ0b29scyB9IGZyb20gJ3p1c3RhbmQvbWlkZGxld2FyZSc7XG5pbXBvcnQgeyBJUHJvc3BlY3QsIFBpcGVsaW5lU3RhZ2UgfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB7IGlvLCBTb2NrZXQgfSBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcblxuLy8gRGF0YWJhc2UgcHJvc3BlY3QgdHlwZSAoZnJvbSBBUEkpXG5pbnRlcmZhY2UgRGF0YWJhc2VQcm9zcGVjdCB7XG4gIGlkOiBzdHJpbmc7XG4gIGJ1c2luZXNzX25hbWU6IHN0cmluZztcbiAgaW5kdXN0cnk6IHN0cmluZztcbiAgbG9jYXRpb246IHN0cmluZztcbiAgY29udGFjdF9uYW1lOiBzdHJpbmcgfCBudWxsO1xuICBjb250YWN0X2VtYWlsOiBzdHJpbmcgfCBudWxsO1xuICBjb250YWN0X3Bob25lOiBzdHJpbmcgfCBudWxsO1xuICB3ZWJzaXRlOiBzdHJpbmcgfCBudWxsO1xuICB0ZW1wZXJhdHVyZTogJ2NvbGQnIHwgJ3dhcm0nIHwgJ2hvdCc7XG4gIHBpcGVsaW5lX3N0YWdlOiAnY29sZCcgfCAnY29udGFjdGVkJyB8ICdpbnRlcmVzdGVkJyB8ICdxdWFsaWZpZWQnO1xuICBzY29yZTogbnVtYmVyO1xuICByZXNlYXJjaF9kYXRhOiBhbnk7XG4gIG5vdGVzOiBzdHJpbmcgfCBudWxsO1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIHVwZGF0ZWRfYXQ6IHN0cmluZztcbn1cblxuLy8gQ29udmVydCBkYXRhYmFzZSBwcm9zcGVjdCB0byBJUHJvc3BlY3RcbmNvbnN0IGNvbnZlcnRUb0lQcm9zcGVjdCA9IChkYlByb3NwZWN0OiBEYXRhYmFzZVByb3NwZWN0KTogSVByb3NwZWN0ID0+IHtcbiAgcmV0dXJuIHtcbiAgICBpZDogZGJQcm9zcGVjdC5pZCxcbiAgICBidXNpbmVzczoge1xuICAgICAgbmFtZTogZGJQcm9zcGVjdC5idXNpbmVzc19uYW1lLFxuICAgICAgaW5kdXN0cnk6IGRiUHJvc3BlY3QuaW5kdXN0cnksXG4gICAgICBsb2NhdGlvbjoge1xuICAgICAgICBhZGRyZXNzOiAnJyxcbiAgICAgICAgY2l0eTogZGJQcm9zcGVjdC5sb2NhdGlvbi5zcGxpdCgnLCcpWzBdPy50cmltKCkgfHwgJycsXG4gICAgICAgIHN0YXRlOiBkYlByb3NwZWN0LmxvY2F0aW9uLnNwbGl0KCcsJylbMV0/LnRyaW0oKSB8fCAnJyxcbiAgICAgICAgemlwQ29kZTogJycsXG4gICAgICAgIGNvdW50cnk6ICdVU0EnLFxuICAgICAgICBjb29yZGluYXRlczogeyBsYXQ6IDAsIGxuZzogMCB9XG4gICAgICB9LFxuICAgICAgd2Vic2l0ZTogZGJQcm9zcGVjdC53ZWJzaXRlIHx8ICcnLFxuICAgICAgZGVzY3JpcHRpb246ICcnLFxuICAgICAgc2l6ZToge1xuICAgICAgICBjYXRlZ29yeTogJ3NtYWxsJyBhcyBhbnksXG4gICAgICAgIGVtcGxveWVlQ291bnQ6IDEwLFxuICAgICAgICBlc3RpbWF0ZWRSZXZlbnVlOiA1MDAwMDBcbiAgICAgIH0sXG4gICAgICBkaWdpdGFsUHJlc2VuY2U6IHtcbiAgICAgICAgaGFzV2Vic2l0ZTogISFkYlByb3NwZWN0LndlYnNpdGUsXG4gICAgICAgIGhhc0dvb2dsZUJ1c2luZXNzOiB0cnVlLFxuICAgICAgICBoYXNTb2NpYWxNZWRpYTogZmFsc2UsXG4gICAgICAgIGhhc09ubGluZVJldmlld3M6IGZhbHNlLFxuICAgICAgICB3ZWJzaXRlVXJsOiBkYlByb3NwZWN0LndlYnNpdGUgfHwgdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfSxcbiAgICBjb250YWN0OiB7XG4gICAgICBwcmltYXJ5Q29udGFjdDogZGJQcm9zcGVjdC5jb250YWN0X25hbWUgfHwgJycsXG4gICAgICBjb250YWN0VGl0bGU6ICdPd25lcicsXG4gICAgICBlbWFpbDogZGJQcm9zcGVjdC5jb250YWN0X2VtYWlsIHx8ICcnLFxuICAgICAgcGhvbmU6IGRiUHJvc3BlY3QuY29udGFjdF9waG9uZSB8fCAnJyxcbiAgICAgIHdlYnNpdGU6IGRiUHJvc3BlY3Qud2Vic2l0ZSB8fCAnJyxcbiAgICAgIGRlY2lzaW9uTWFrZXI6ICdZZXMnLFxuICAgICAgc29jaWFsUHJvZmlsZXM6IHt9XG4gICAgfSxcbiAgICBwaXBlbGluZVN0YWdlOiBkYlByb3NwZWN0LnBpcGVsaW5lX3N0YWdlIGFzIFBpcGVsaW5lU3RhZ2UsXG4gICAgcXVhbGlmaWNhdGlvblNjb3JlOiB7XG4gICAgICB0b3RhbDogZGJQcm9zcGVjdC5zY29yZSxcbiAgICAgIGJyZWFrZG93bjoge1xuICAgICAgICBidXNpbmVzc1NpemU6IDE1LFxuICAgICAgICBkaWdpdGFsUHJlc2VuY2U6IDIwLFxuICAgICAgICBjb21wZXRpdG9yR2FwczogMTUsXG4gICAgICAgIGxvY2F0aW9uOiAxMCxcbiAgICAgICAgaW5kdXN0cnk6IDUsXG4gICAgICAgIHJldmVudWVJbmRpY2F0b3JzOiA1XG4gICAgICB9LFxuICAgICAgcXVhbGlmaWNhdGlvbkxldmVsOiBkYlByb3NwZWN0LnNjb3JlID4gNzAgPyAnaGlnaCcgOiBkYlByb3NwZWN0LnNjb3JlID4gNDAgPyAnbWVkaXVtJyA6ICdsb3cnLFxuICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKGRiUHJvc3BlY3QudXBkYXRlZF9hdClcbiAgICB9LFxuICAgIHJlc2VhcmNoUGFzc2VzOiBbXG4gICAgICB7XG4gICAgICAgIHBhc3NOdW1iZXI6IDEsXG4gICAgICAgIHR5cGU6ICdnb29nbGVfbWFwcycsXG4gICAgICAgIHN0YXR1czogJ2NvbXBsZXRlZCcsXG4gICAgICAgIGNvbXBsZXRlZEF0OiBuZXcgRGF0ZShkYlByb3NwZWN0LmNyZWF0ZWRfYXQpLFxuICAgICAgICBkYXRhQ29sbGVjdGVkOiB7fSxcbiAgICAgICAgcmV0cnlDb3VudDogMCxcbiAgICAgICAgc291cmNlOiB7IGFwaTogJ0dvb2dsZSBNYXBzIEFQSScgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcGFzc051bWJlcjogMixcbiAgICAgICAgdHlwZTogJ2ZpcmVjcmF3bCcsXG4gICAgICAgIHN0YXR1czogJ2NvbXBsZXRlZCcsXG4gICAgICAgIGNvbXBsZXRlZEF0OiBuZXcgRGF0ZShkYlByb3NwZWN0LmNyZWF0ZWRfYXQpLFxuICAgICAgICBkYXRhQ29sbGVjdGVkOiB7fSxcbiAgICAgICAgcmV0cnlDb3VudDogMCxcbiAgICAgICAgc291cmNlOiB7IGFwaTogJ0ZpcmVjcmF3bCcgfVxuICAgICAgfVxuICAgIF0sXG4gICAgZGF0YUNvbmZpZGVuY2U6IDg1LFxuICAgIGJ1c2luZXNzSW5zaWdodHM6IHtcbiAgICAgIHBhaW5Qb2ludHM6IFsnTGltaXRlZCBvbmxpbmUgcHJlc2VuY2UnXSxcbiAgICAgIGNvbXBldGl0aXZlQWR2YW50YWdlczogWydTdHJvbmcgbG9jYWwgcmVwdXRhdGlvbiddXG4gICAgfSxcbiAgICB0YWdzOiBbJ3Byb3NwZWN0JywgZGJQcm9zcGVjdC5pbmR1c3RyeV0sXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShkYlByb3NwZWN0LmNyZWF0ZWRfYXQpLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoZGJQcm9zcGVjdC51cGRhdGVkX2F0KVxuICB9O1xufTtcblxuaW50ZXJmYWNlIFBpcGVsaW5lU3RhdGUge1xuICAvLyBQcm9zcGVjdHNcbiAgcHJvc3BlY3RzOiBJUHJvc3BlY3RbXTtcbiAgc2VsZWN0ZWRQcm9zcGVjdDogSVByb3NwZWN0IHwgbnVsbDtcbiAgc2V0U2VsZWN0ZWRQcm9zcGVjdDogKHByb3NwZWN0OiBJUHJvc3BlY3QgfCBudWxsKSA9PiB2b2lkO1xuXG4gIC8vIExvYWRpbmcgc3RhdGVzXG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XG5cbiAgLy8gUmVhbC10aW1lIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gIHNvY2tldDogU29ja2V0IHwgbnVsbDtcbiAgd3NDb25uZWN0ZWQ6IGJvb2xlYW47XG4gIHdzQ29ubmVjdGluZzogYm9vbGVhbjtcblxuICAvLyBGaWx0ZXJpbmdcbiAgc3RhZ2VGaWx0ZXI6IFBpcGVsaW5lU3RhZ2UgfCAnYWxsJztcbiAgc2V0U3RhZ2VGaWx0ZXI6IChzdGFnZTogUGlwZWxpbmVTdGFnZSB8ICdhbGwnKSA9PiB2b2lkO1xuICBpbmR1c3RyeUZpbHRlcjogc3RyaW5nIHwgJ2FsbCc7XG4gIHNldEluZHVzdHJ5RmlsdGVyOiAoaW5kdXN0cnk6IHN0cmluZyB8ICdhbGwnKSA9PiB2b2lkO1xuICBzZWFyY2hRdWVyeTogc3RyaW5nO1xuICBzZXRTZWFyY2hRdWVyeTogKHF1ZXJ5OiBzdHJpbmcpID0+IHZvaWQ7XG5cbiAgLy8gQWN0aW9uc1xuICBmZXRjaFByb3NwZWN0czogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgbW92ZVByb3NwZWN0OiAocHJvc3BlY3RJZDogc3RyaW5nLCBuZXdTdGFnZTogUGlwZWxpbmVTdGFnZSkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgdXBkYXRlUHJvc3BlY3RTY29yZTogKHByb3NwZWN0SWQ6IHN0cmluZywgc2NvcmU6IG51bWJlcikgPT4gUHJvbWlzZTx2b2lkPjtcbiAgYWRkUHJvc3BlY3Q6IChwcm9zcGVjdDogT21pdDxJUHJvc3BlY3QsICdpZCc+KSA9PiBQcm9taXNlPHZvaWQ+O1xuICB1cGRhdGVQcm9zcGVjdDogKHByb3NwZWN0SWQ6IHN0cmluZywgdXBkYXRlczogYW55KSA9PiBQcm9taXNlPHZvaWQ+O1xuICBkZWxldGVQcm9zcGVjdDogKHByb3NwZWN0SWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcblxuICAvLyBSZWFsLXRpbWUgV2ViU29ja2V0XG4gIGNvbm5lY3RXZWJTb2NrZXQ6ICgpID0+IHZvaWQ7XG4gIGRpc2Nvbm5lY3RXZWJTb2NrZXQ6ICgpID0+IHZvaWQ7XG4gIHN1YnNjcmliZVRvQ2hhbmdlczogKCkgPT4gdm9pZDtcbiAgdW5zdWJzY3JpYmVGcm9tQ2hhbmdlczogKCkgPT4gdm9pZDtcblxuICAvLyBSZXNlYXJjaFxuICByZXNlYXJjaFF1ZXVlOiBzdHJpbmdbXTtcbiAgYWRkVG9SZXNlYXJjaFF1ZXVlOiAocHJvc3BlY3RJZDogc3RyaW5nKSA9PiB2b2lkO1xuICByZW1vdmVGcm9tUmVzZWFyY2hRdWV1ZTogKHByb3NwZWN0SWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgaXNSZXNlYXJjaGluZzogYm9vbGVhbjtcbiAgc2V0SXNSZXNlYXJjaGluZzogKHJlc2VhcmNoaW5nOiBib29sZWFuKSA9PiB2b2lkO1xuXG4gIC8vIE5vdGlmaWNhdGlvbnNcbiAgbm90aWZpY2F0aW9uczogQXJyYXk8e1xuICAgIGlkOiBzdHJpbmc7XG4gICAgdHlwZTogJ2luZm8nIHwgJ3N1Y2Nlc3MnIHwgJ3dhcm5pbmcnIHwgJ2Vycm9yJztcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgdGltZXN0YW1wOiBEYXRlO1xuICB9PjtcbiAgYWRkTm90aWZpY2F0aW9uOiAobm90aWZpY2F0aW9uOiBPbWl0PFBpcGVsaW5lU3RhdGVbJ25vdGlmaWNhdGlvbnMnXVswXSwgJ2lkJyB8ICd0aW1lc3RhbXAnPikgPT4gdm9pZDtcbiAgcmVtb3ZlTm90aWZpY2F0aW9uOiAoaWQ6IHN0cmluZykgPT4gdm9pZDtcblxuICAvLyBDb21wdXRlZCB2YWx1ZXNcbiAgZ2V0RmlsdGVyZWRQcm9zcGVjdHM6ICgpID0+IElQcm9zcGVjdFtdO1xuICBnZXRTdGFnZUNvdW50OiAoc3RhZ2U6IFBpcGVsaW5lU3RhZ2UpID0+IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IHVzZVBpcGVsaW5lU3RvcmVXaXRoU3VwYWJhc2UgPSBjcmVhdGU8UGlwZWxpbmVTdGF0ZT4oKShcbiAgZGV2dG9vbHMoXG4gICAgKHNldCwgZ2V0KSA9PiAoe1xuICAgICAgLy8gUHJvc3BlY3RzXG4gICAgICBwcm9zcGVjdHM6IFtdLFxuICAgICAgc2VsZWN0ZWRQcm9zcGVjdDogbnVsbCxcbiAgICAgIHNldFNlbGVjdGVkUHJvc3BlY3Q6IChwcm9zcGVjdCkgPT4gc2V0KHsgc2VsZWN0ZWRQcm9zcGVjdDogcHJvc3BlY3QgfSksXG5cbiAgICAgIC8vIExvYWRpbmcgc3RhdGVzXG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgZXJyb3I6IG51bGwsXG5cbiAgICAgIC8vIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gICAgICBzb2NrZXQ6IG51bGwsXG4gICAgICB3c0Nvbm5lY3RlZDogZmFsc2UsXG4gICAgICB3c0Nvbm5lY3Rpbmc6IGZhbHNlLFxuICAgICAgXG4gICAgICAvLyBGaWx0ZXJpbmdcbiAgICAgIHN0YWdlRmlsdGVyOiAnYWxsJyxcbiAgICAgIHNldFN0YWdlRmlsdGVyOiAoc3RhZ2UpID0+IHNldCh7IHN0YWdlRmlsdGVyOiBzdGFnZSB9KSxcbiAgICAgIGluZHVzdHJ5RmlsdGVyOiAnYWxsJyxcbiAgICAgIHNldEluZHVzdHJ5RmlsdGVyOiAoaW5kdXN0cnkpID0+IHNldCh7IGluZHVzdHJ5RmlsdGVyOiBpbmR1c3RyeSB9KSxcbiAgICAgIHNlYXJjaFF1ZXJ5OiAnJyxcbiAgICAgIHNldFNlYXJjaFF1ZXJ5OiAocXVlcnkpID0+IHNldCh7IHNlYXJjaFF1ZXJ5OiBxdWVyeSB9KSxcbiAgICAgIFxuICAgICAgLy8gQWN0aW9uc1xuICAgICAgZmV0Y2hQcm9zcGVjdHM6IGFzeW5jICgpID0+IHtcbiAgICAgICAgc2V0KHsgaXNMb2FkaW5nOiB0cnVlLCBlcnJvcjogbnVsbCB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3Byb3NwZWN0cycpO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgY29uc3QgcHJvc3BlY3RzID0gcmVzdWx0LmRhdGEubWFwKGNvbnZlcnRUb0lQcm9zcGVjdCk7XG4gICAgICAgICAgICBzZXQoeyBwcm9zcGVjdHMsIGlzTG9hZGluZzogZmFsc2UgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldCh7IGVycm9yOiByZXN1bHQuZXJyb3IgfHwgJ0ZhaWxlZCB0byBmZXRjaCBwcm9zcGVjdHMnLCBpc0xvYWRpbmc6IGZhbHNlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBzZXQoeyBlcnJvcjogJ0ZhaWxlZCB0byBmZXRjaCBwcm9zcGVjdHMnLCBpc0xvYWRpbmc6IGZhbHNlIH0pO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByb3NwZWN0czonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcbiAgICAgIG1vdmVQcm9zcGVjdDogYXN5bmMgKHByb3NwZWN0SWQsIG5ld1N0YWdlKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9wcm9zcGVjdHM/aWQ9JHtwcm9zcGVjdElkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcGlwZWxpbmVfc3RhZ2U6IG5ld1N0YWdlIH0pXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgbG9jYWwgc3RhdGUgb3B0aW1pc3RpY2FsbHlcbiAgICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgICAgIHByb3NwZWN0czogc3RhdGUucHJvc3BlY3RzLm1hcChwID0+XG4gICAgICAgICAgICAgICAgcC5pZCA9PT0gcHJvc3BlY3RJZCA/IHsgLi4ucCwgcGlwZWxpbmVTdGFnZTogbmV3U3RhZ2UgfSA6IHBcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXQoeyBlcnJvcjogcmVzdWx0LmVycm9yIHx8ICdGYWlsZWQgdG8gdXBkYXRlIHByb3NwZWN0IHN0YWdlJyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbW92aW5nIHByb3NwZWN0OicsIGVycm9yKTtcbiAgICAgICAgICBzZXQoeyBlcnJvcjogJ0ZhaWxlZCB0byB1cGRhdGUgcHJvc3BlY3Qgc3RhZ2UnIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXG4gICAgICB1cGRhdGVQcm9zcGVjdFNjb3JlOiBhc3luYyAocHJvc3BlY3RJZCwgc2NvcmUpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3Byb3NwZWN0cz9pZD0ke3Byb3NwZWN0SWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBzY29yZSB9KVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGxvY2FsIHN0YXRlXG4gICAgICAgICAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgICBwcm9zcGVjdHM6IHN0YXRlLnByb3NwZWN0cy5tYXAocCA9PlxuICAgICAgICAgICAgICAgIHAuaWQgPT09IHByb3NwZWN0SWRcbiAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgIC4uLnAsXG4gICAgICAgICAgICAgICAgICAgICAgcXVhbGlmaWNhdGlvblNjb3JlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wLnF1YWxpZmljYXRpb25TY29yZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsOiBzY29yZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YWxpZmljYXRpb25MZXZlbDogc2NvcmUgPiA3MCA/ICdoaWdoJyA6IHNjb3JlID4gNDAgPyAnbWVkaXVtJyA6ICdsb3cnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKClcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIDogcFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldCh7IGVycm9yOiByZXN1bHQuZXJyb3IgfHwgJ0ZhaWxlZCB0byB1cGRhdGUgcHJvc3BlY3Qgc2NvcmUnIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBwcm9zcGVjdCBzY29yZTonLCBlcnJvcik7XG4gICAgICAgICAgc2V0KHsgZXJyb3I6ICdGYWlsZWQgdG8gdXBkYXRlIHByb3NwZWN0IHNjb3JlJyB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFxuICAgICAgYWRkUHJvc3BlY3Q6IGFzeW5jIChwcm9zcGVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvcHJvc3BlY3RzJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgYnVzaW5lc3NfbmFtZTogcHJvc3BlY3QuYnVzaW5lc3MubmFtZSxcbiAgICAgICAgICAgICAgaW5kdXN0cnk6IHByb3NwZWN0LmJ1c2luZXNzLmluZHVzdHJ5LFxuICAgICAgICAgICAgICBsb2NhdGlvbjogYCR7cHJvc3BlY3QuYnVzaW5lc3MubG9jYXRpb24uY2l0eX0sICR7cHJvc3BlY3QuYnVzaW5lc3MubG9jYXRpb24uc3RhdGV9YCxcbiAgICAgICAgICAgICAgY29udGFjdF9uYW1lOiBwcm9zcGVjdC5jb250YWN0LnByaW1hcnlDb250YWN0LFxuICAgICAgICAgICAgICBjb250YWN0X2VtYWlsOiBwcm9zcGVjdC5jb250YWN0LmVtYWlsLFxuICAgICAgICAgICAgICBjb250YWN0X3Bob25lOiBwcm9zcGVjdC5jb250YWN0LnBob25lLFxuICAgICAgICAgICAgICB3ZWJzaXRlOiBwcm9zcGVjdC5idXNpbmVzcy53ZWJzaXRlLFxuICAgICAgICAgICAgICB0ZW1wZXJhdHVyZTogcHJvc3BlY3QudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgIHBpcGVsaW5lX3N0YWdlOiBwcm9zcGVjdC5waXBlbGluZVN0YWdlLFxuICAgICAgICAgICAgICBzY29yZTogcHJvc3BlY3QucXVhbGlmaWNhdGlvblNjb3JlLnRvdGFsLFxuICAgICAgICAgICAgICBub3RlczogcHJvc3BlY3Qubm90ZXNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBjb25zdCBpUHJvc3BlY3QgPSBjb252ZXJ0VG9JUHJvc3BlY3QocmVzdWx0LmRhdGEpO1xuICAgICAgICAgICAgc2V0KChzdGF0ZSkgPT4gKHsgcHJvc3BlY3RzOiBbLi4uc3RhdGUucHJvc3BlY3RzLCBpUHJvc3BlY3RdIH0pKTtcblxuICAgICAgICAgICAgZ2V0KCkuYWRkTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBgUHJvc3BlY3QgJHtpUHJvc3BlY3QuYnVzaW5lc3MubmFtZX0gYWRkZWQgc3VjY2Vzc2Z1bGx5YFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldCh7IGVycm9yOiByZXN1bHQuZXJyb3IgfHwgJ0ZhaWxlZCB0byBhZGQgcHJvc3BlY3QnIH0pO1xuICAgICAgICAgICAgZ2V0KCkuYWRkTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogcmVzdWx0LmVycm9yIHx8ICdGYWlsZWQgdG8gYWRkIHByb3NwZWN0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBwcm9zcGVjdDonLCBlcnJvcik7XG4gICAgICAgICAgc2V0KHsgZXJyb3I6ICdGYWlsZWQgdG8gYWRkIHByb3NwZWN0JyB9KTtcbiAgICAgICAgICBnZXQoKS5hZGROb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gYWRkIHByb3NwZWN0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB1cGRhdGVQcm9zcGVjdDogYXN5bmMgKHByb3NwZWN0SWQsIHVwZGF0ZXMpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3Byb3NwZWN0cz9pZD0ke3Byb3NwZWN0SWR9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXBkYXRlcylcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRJUHJvc3BlY3QgPSBjb252ZXJ0VG9JUHJvc3BlY3QocmVzdWx0LmRhdGEpO1xuICAgICAgICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICAgICAgcHJvc3BlY3RzOiBzdGF0ZS5wcm9zcGVjdHMubWFwKHAgPT5cbiAgICAgICAgICAgICAgICBwLmlkID09PSBwcm9zcGVjdElkID8gdXBkYXRlZElQcm9zcGVjdCA6IHBcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBnZXQoKS5hZGROb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGBQcm9zcGVjdCAke3VwZGF0ZWRJUHJvc3BlY3QuYnVzaW5lc3MubmFtZX0gdXBkYXRlZCBzdWNjZXNzZnVsbHlgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0KHsgZXJyb3I6IHJlc3VsdC5lcnJvciB8fCAnRmFpbGVkIHRvIHVwZGF0ZSBwcm9zcGVjdCcgfSk7XG4gICAgICAgICAgICBnZXQoKS5hZGROb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICBtZXNzYWdlOiByZXN1bHQuZXJyb3IgfHwgJ0ZhaWxlZCB0byB1cGRhdGUgcHJvc3BlY3QnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgcHJvc3BlY3Q6JywgZXJyb3IpO1xuICAgICAgICAgIHNldCh7IGVycm9yOiAnRmFpbGVkIHRvIHVwZGF0ZSBwcm9zcGVjdCcgfSk7XG4gICAgICAgICAgZ2V0KCkuYWRkTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIHVwZGF0ZSBwcm9zcGVjdCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFxuICAgICAgZGVsZXRlUHJvc3BlY3Q6IGFzeW5jIChwcm9zcGVjdElkKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcHJvc3BlY3QgPSBnZXQoKS5wcm9zcGVjdHMuZmluZChwID0+IHAuaWQgPT09IHByb3NwZWN0SWQpO1xuXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9wcm9zcGVjdHM/aWQ9JHtwcm9zcGVjdElkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURSdcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgICAgIHByb3NwZWN0czogc3RhdGUucHJvc3BlY3RzLmZpbHRlcihwID0+IHAuaWQgIT09IHByb3NwZWN0SWQpLFxuICAgICAgICAgICAgICBzZWxlY3RlZFByb3NwZWN0OiBzdGF0ZS5zZWxlY3RlZFByb3NwZWN0Py5pZCA9PT0gcHJvc3BlY3RJZCA/IG51bGwgOiBzdGF0ZS5zZWxlY3RlZFByb3NwZWN0XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGdldCgpLmFkZE5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogYFByb3NwZWN0ICR7cHJvc3BlY3Q/LmJ1c2luZXNzLm5hbWUgfHwgJ2RlbGV0ZWQnfSByZW1vdmVkIHN1Y2Nlc3NmdWxseWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXQoeyBlcnJvcjogcmVzdWx0LmVycm9yIHx8ICdGYWlsZWQgdG8gZGVsZXRlIHByb3NwZWN0JyB9KTtcbiAgICAgICAgICAgIGdldCgpLmFkZE5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3VsdC5lcnJvciB8fCAnRmFpbGVkIHRvIGRlbGV0ZSBwcm9zcGVjdCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBwcm9zcGVjdDonLCBlcnJvcik7XG4gICAgICAgICAgc2V0KHsgZXJyb3I6ICdGYWlsZWQgdG8gZGVsZXRlIHByb3NwZWN0JyB9KTtcbiAgICAgICAgICBnZXQoKS5hZGROb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gZGVsZXRlIHByb3NwZWN0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXG4gICAgICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvbiBtYW5hZ2VtZW50XG4gICAgICBjb25uZWN0V2ViU29ja2V0OiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIGlmIChzdGF0ZS5zb2NrZXQ/LmNvbm5lY3RlZCB8fCBzdGF0ZS53c0Nvbm5lY3RpbmcpIHJldHVybjtcblxuICAgICAgICBzZXQoeyB3c0Nvbm5lY3Rpbmc6IHRydWUsIGVycm9yOiBudWxsIH0pO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc29ja2V0ID0gaW8oJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMScsIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydHM6IFsnd2Vic29ja2V0J10sXG4gICAgICAgICAgICB0aW1lb3V0OiA1MDAwLFxuICAgICAgICAgICAgZm9yY2VOZXc6IHRydWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHNvY2tldC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXZWJTb2NrZXQgY29ubmVjdGVkIHRvIHByb3NwZWN0IHVwZGF0ZXMnKTtcbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgICAgd3NDb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHdzQ29ubmVjdGluZzogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGNoYW5nZXMgYXV0b21hdGljYWxseSBvbiBjb25uZWN0XG4gICAgICAgICAgICBnZXQoKS5zdWJzY3JpYmVUb0NoYW5nZXMoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHNvY2tldC5vbignZGlzY29ubmVjdCcsIChyZWFzb24pID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXZWJTb2NrZXQgZGlzY29ubmVjdGVkOicsIHJlYXNvbik7XG4gICAgICAgICAgICBzZXQoeyB3c0Nvbm5lY3RlZDogZmFsc2UgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzb2NrZXQub24oJ2Nvbm5lY3RfZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1dlYlNvY2tldCBjb25uZWN0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgIHdzQ29ubmVjdGluZzogZmFsc2UsXG4gICAgICAgICAgICAgIHdzQ29ubmVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6ICdGYWlsZWQgdG8gY29ubmVjdCB0byByZWFsLXRpbWUgdXBkYXRlcydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgc2V0KHsgc29ja2V0IH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgV2ViU29ja2V0IGNvbm5lY3Rpb246JywgZXJyb3IpO1xuICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICB3c0Nvbm5lY3Rpbmc6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdGYWlsZWQgdG8gaW5pdGlhbGl6ZSByZWFsLXRpbWUgdXBkYXRlcydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZGlzY29ubmVjdFdlYlNvY2tldDogKCkgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICBpZiAoc3RhdGUuc29ja2V0KSB7XG4gICAgICAgICAgc3RhdGUuc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgc29ja2V0OiBudWxsLFxuICAgICAgICAgICAgd3NDb25uZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgd3NDb25uZWN0aW5nOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBSZWFsLXRpbWUgZXZlbnQgc3Vic2NyaXB0aW9uc1xuICAgICAgc3Vic2NyaWJlVG9DaGFuZ2VzOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIGlmICghc3RhdGUuc29ja2V0KSByZXR1cm47XG5cbiAgICAgICAgLy8gTGlzdGVuIGZvciBwcm9zcGVjdCB1cGRhdGVzXG4gICAgICAgIHN0YXRlLnNvY2tldC5vbigncHJvc3BlY3Q6dXBkYXRlZCcsIChkYXRhKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9zcGVjdElkLCB1cGRhdGVzIH0gPSBkYXRhO1xuICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgICBwcm9zcGVjdHM6IHN0YXRlLnByb3NwZWN0cy5tYXAocCA9PlxuICAgICAgICAgICAgICBwLmlkID09PSBwcm9zcGVjdElkID8geyAuLi5wLCAuLi51cGRhdGVzIH0gOiBwXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgZ2V0KCkuYWRkTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICdpbmZvJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBQcm9zcGVjdCAke3VwZGF0ZXMuYnVzaW5lc3M/Lm5hbWUgfHwgcHJvc3BlY3RJZH0gdXBkYXRlZGBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTGlzdGVuIGZvciBwcm9zcGVjdCBzdGFnZSBjaGFuZ2VzXG4gICAgICAgIHN0YXRlLnNvY2tldC5vbigncHJvc3BlY3Q6c3RhZ2VfY2hhbmdlZCcsIChkYXRhKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBwcm9zcGVjdElkLCBuZXdTdGFnZSwgb2xkU3RhZ2UgfSA9IGRhdGE7XG4gICAgICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICAgIHByb3NwZWN0czogc3RhdGUucHJvc3BlY3RzLm1hcChwID0+XG4gICAgICAgICAgICAgIHAuaWQgPT09IHByb3NwZWN0SWQgPyB7IC4uLnAsIHBpcGVsaW5lU3RhZ2U6IG5ld1N0YWdlIH0gOiBwXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgZ2V0KCkuYWRkTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBQcm9zcGVjdCBtb3ZlZCBmcm9tICR7b2xkU3RhZ2V9IHRvICR7bmV3U3RhZ2V9YFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBMaXN0ZW4gZm9yIG5ldyBwcm9zcGVjdHNcbiAgICAgICAgc3RhdGUuc29ja2V0Lm9uKCdwcm9zcGVjdDpjcmVhdGVkJywgKGRhdGEpID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdQcm9zcGVjdCA9IGNvbnZlcnRUb0lQcm9zcGVjdChkYXRhLnByb3NwZWN0KTtcbiAgICAgICAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgcHJvc3BlY3RzOiBbLi4uc3RhdGUucHJvc3BlY3RzLCBuZXdQcm9zcGVjdF1cbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBnZXQoKS5hZGROb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgbWVzc2FnZTogYE5ldyBwcm9zcGVjdCBhZGRlZDogJHtuZXdQcm9zcGVjdC5idXNpbmVzcy5uYW1lfWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTGlzdGVuIGZvciByZXNlYXJjaCBwcm9ncmVzc1xuICAgICAgICBzdGF0ZS5zb2NrZXQub24oJ3Jlc2VhcmNoOnByb2dyZXNzJywgKGRhdGEpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb3NwZWN0SWQsIHN0YWdlLCBwcm9ncmVzcyB9ID0gZGF0YTtcblxuICAgICAgICAgIGdldCgpLmFkZE5vdGlmaWNhdGlvbih7XG4gICAgICAgICAgICB0eXBlOiAnaW5mbycsXG4gICAgICAgICAgICBtZXNzYWdlOiBgUmVzZWFyY2ggJHtzdGFnZX0gKCR7cHJvZ3Jlc3N9JSkgZm9yIHByb3NwZWN0ICR7cHJvc3BlY3RJZH1gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN0YXRlLnNvY2tldC5vbigncmVzZWFyY2g6Y29tcGxldGVkJywgKGRhdGEpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHByb3NwZWN0SWQsIHN1Y2Nlc3MgfSA9IGRhdGE7XG5cbiAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgLy8gUmVmcmVzaCBwcm9zcGVjdCBkYXRhXG4gICAgICAgICAgICBnZXQoKS5mZXRjaFByb3NwZWN0cygpO1xuXG4gICAgICAgICAgICBnZXQoKS5hZGROb3RpZmljYXRpb24oe1xuICAgICAgICAgICAgICB0eXBlOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGBSZXNlYXJjaCBjb21wbGV0ZWQgZm9yIHByb3NwZWN0ICR7cHJvc3BlY3RJZH1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN5c3RlbSBhbGVydHNcbiAgICAgICAgc3RhdGUuc29ja2V0Lm9uKCdzeXN0ZW06YWxlcnQnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgbGV2ZWwsIG1lc3NhZ2UgfSA9IGRhdGE7XG4gICAgICAgICAgZ2V0KCkuYWRkTm90aWZpY2F0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6IGxldmVsID09PSAnZXJyb3InID8gJ2Vycm9yJyA6IGxldmVsID09PSAnd2FybmluZycgPyAnd2FybmluZycgOiAnaW5mbycsXG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdTdWJzY3JpYmVkIHRvIHJlYWwtdGltZSBwcm9zcGVjdCB1cGRhdGVzJyk7XG4gICAgICB9LFxuXG4gICAgICB1bnN1YnNjcmliZUZyb21DaGFuZ2VzOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIGlmIChzdGF0ZS5zb2NrZXQpIHtcbiAgICAgICAgICBzdGF0ZS5zb2NrZXQub2ZmKCdwcm9zcGVjdDp1cGRhdGVkJyk7XG4gICAgICAgICAgc3RhdGUuc29ja2V0Lm9mZigncHJvc3BlY3Q6c3RhZ2VfY2hhbmdlZCcpO1xuICAgICAgICAgIHN0YXRlLnNvY2tldC5vZmYoJ3Byb3NwZWN0OmNyZWF0ZWQnKTtcbiAgICAgICAgICBzdGF0ZS5zb2NrZXQub2ZmKCdyZXNlYXJjaDpwcm9ncmVzcycpO1xuICAgICAgICAgIHN0YXRlLnNvY2tldC5vZmYoJ3Jlc2VhcmNoOmNvbXBsZXRlZCcpO1xuICAgICAgICAgIHN0YXRlLnNvY2tldC5vZmYoJ3N5c3RlbTphbGVydCcpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdVbnN1YnNjcmliZWQgZnJvbSByZWFsLXRpbWUgdXBkYXRlcycpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXG4gICAgICAvLyBSZXNlYXJjaFxuICAgICAgcmVzZWFyY2hRdWV1ZTogW10sXG4gICAgICBhZGRUb1Jlc2VhcmNoUXVldWU6IChwcm9zcGVjdElkKSA9PiBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICByZXNlYXJjaFF1ZXVlOiBbLi4uc3RhdGUucmVzZWFyY2hRdWV1ZSwgcHJvc3BlY3RJZF1cbiAgICAgIH0pKSxcbiAgICAgIHJlbW92ZUZyb21SZXNlYXJjaFF1ZXVlOiAocHJvc3BlY3RJZCkgPT4gc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgcmVzZWFyY2hRdWV1ZTogc3RhdGUucmVzZWFyY2hRdWV1ZS5maWx0ZXIoaWQgPT4gaWQgIT09IHByb3NwZWN0SWQpXG4gICAgICB9KSksXG4gICAgICBpc1Jlc2VhcmNoaW5nOiBmYWxzZSxcbiAgICAgIHNldElzUmVzZWFyY2hpbmc6IChyZXNlYXJjaGluZykgPT4gc2V0KHsgaXNSZXNlYXJjaGluZzogcmVzZWFyY2hpbmcgfSksXG5cbiAgICAgIC8vIE5vdGlmaWNhdGlvbnNcbiAgICAgIG5vdGlmaWNhdGlvbnM6IFtdLFxuICAgICAgYWRkTm90aWZpY2F0aW9uOiAobm90aWZpY2F0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gYG5vdGlmaWNhdGlvbi0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG4gICAgICAgIGNvbnN0IG5ld05vdGlmaWNhdGlvbiA9IHtcbiAgICAgICAgICAuLi5ub3RpZmljYXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXG4gICAgICAgIH07XG5cbiAgICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICBub3RpZmljYXRpb25zOiBbLi4uc3RhdGUubm90aWZpY2F0aW9ucywgbmV3Tm90aWZpY2F0aW9uXVxuICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gQXV0by1yZW1vdmUgaW5mbyBub3RpZmljYXRpb25zIGFmdGVyIDUgc2Vjb25kc1xuICAgICAgICBpZiAobm90aWZpY2F0aW9uLnR5cGUgPT09ICdpbmZvJykge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZ2V0KCkucmVtb3ZlTm90aWZpY2F0aW9uKGlkKTtcbiAgICAgICAgICB9LCA1MDAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChub3RpZmljYXRpb24udHlwZSA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBnZXQoKS5yZW1vdmVOb3RpZmljYXRpb24oaWQpO1xuICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICByZW1vdmVOb3RpZmljYXRpb246IChpZCkgPT4ge1xuICAgICAgICBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICAgIG5vdGlmaWNhdGlvbnM6IHN0YXRlLm5vdGlmaWNhdGlvbnMuZmlsdGVyKG4gPT4gbi5pZCAhPT0gaWQpXG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIC8vIENvbXB1dGVkIHZhbHVlc1xuICAgICAgZ2V0RmlsdGVyZWRQcm9zcGVjdHM6ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICAgICAgbGV0IGZpbHRlcmVkID0gWy4uLnN0YXRlLnByb3NwZWN0c107XG4gICAgICAgIFxuICAgICAgICAvLyBTdGFnZSBmaWx0ZXJcbiAgICAgICAgaWYgKHN0YXRlLnN0YWdlRmlsdGVyICE9PSAnYWxsJykge1xuICAgICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQuZmlsdGVyKHAgPT4gcC5waXBlbGluZVN0YWdlID09PSBzdGF0ZS5zdGFnZUZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEluZHVzdHJ5IGZpbHRlclxuICAgICAgICBpZiAoc3RhdGUuaW5kdXN0cnlGaWx0ZXIgIT09ICdhbGwnKSB7XG4gICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIocCA9PiBwLmJ1c2luZXNzLmluZHVzdHJ5ID09PSBzdGF0ZS5pbmR1c3RyeUZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNlYXJjaFxuICAgICAgICBpZiAoc3RhdGUuc2VhcmNoUXVlcnkpIHtcbiAgICAgICAgICBjb25zdCBxdWVyeSA9IHN0YXRlLnNlYXJjaFF1ZXJ5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIocCA9PiBcbiAgICAgICAgICAgIHAuYnVzaW5lc3MubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5KSB8fFxuICAgICAgICAgICAgcC5jb250YWN0LnByaW1hcnlDb250YWN0LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnkpIHx8XG4gICAgICAgICAgICBwLmJ1c2luZXNzLmxvY2F0aW9uLmNpdHkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgICB9LFxuICAgICAgXG4gICAgICBnZXRTdGFnZUNvdW50OiAoc3RhZ2UpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICAgICAgaWYgKHN0YWdlID09PSAnY29sZCcpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUucHJvc3BlY3RzLmZpbHRlcihwID0+IHAudGVtcGVyYXR1cmUgPT09ICdjb2xkJykubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZS5wcm9zcGVjdHMuZmlsdGVyKHAgPT4gcC5waXBlbGluZVN0YWdlID09PSBzdGFnZSkubGVuZ3RoO1xuICAgICAgfSxcbiAgICB9KSxcbiAgICB7XG4gICAgICBuYW1lOiAncGlwZWxpbmUtc3RvcmUnXG4gICAgfVxuICApXG4pOyJdLCJuYW1lcyI6WyJjcmVhdGUiLCJkZXZ0b29scyIsImlvIiwiY29udmVydFRvSVByb3NwZWN0IiwiZGJQcm9zcGVjdCIsImlkIiwiYnVzaW5lc3MiLCJuYW1lIiwiYnVzaW5lc3NfbmFtZSIsImluZHVzdHJ5IiwibG9jYXRpb24iLCJhZGRyZXNzIiwiY2l0eSIsInNwbGl0IiwidHJpbSIsInN0YXRlIiwiemlwQ29kZSIsImNvdW50cnkiLCJjb29yZGluYXRlcyIsImxhdCIsImxuZyIsIndlYnNpdGUiLCJkZXNjcmlwdGlvbiIsInNpemUiLCJjYXRlZ29yeSIsImVtcGxveWVlQ291bnQiLCJlc3RpbWF0ZWRSZXZlbnVlIiwiZGlnaXRhbFByZXNlbmNlIiwiaGFzV2Vic2l0ZSIsImhhc0dvb2dsZUJ1c2luZXNzIiwiaGFzU29jaWFsTWVkaWEiLCJoYXNPbmxpbmVSZXZpZXdzIiwid2Vic2l0ZVVybCIsInVuZGVmaW5lZCIsImNvbnRhY3QiLCJwcmltYXJ5Q29udGFjdCIsImNvbnRhY3RfbmFtZSIsImNvbnRhY3RUaXRsZSIsImVtYWlsIiwiY29udGFjdF9lbWFpbCIsInBob25lIiwiY29udGFjdF9waG9uZSIsImRlY2lzaW9uTWFrZXIiLCJzb2NpYWxQcm9maWxlcyIsInBpcGVsaW5lU3RhZ2UiLCJwaXBlbGluZV9zdGFnZSIsInF1YWxpZmljYXRpb25TY29yZSIsInRvdGFsIiwic2NvcmUiLCJicmVha2Rvd24iLCJidXNpbmVzc1NpemUiLCJjb21wZXRpdG9yR2FwcyIsInJldmVudWVJbmRpY2F0b3JzIiwicXVhbGlmaWNhdGlvbkxldmVsIiwibGFzdFVwZGF0ZWQiLCJEYXRlIiwidXBkYXRlZF9hdCIsInJlc2VhcmNoUGFzc2VzIiwicGFzc051bWJlciIsInR5cGUiLCJzdGF0dXMiLCJjb21wbGV0ZWRBdCIsImNyZWF0ZWRfYXQiLCJkYXRhQ29sbGVjdGVkIiwicmV0cnlDb3VudCIsInNvdXJjZSIsImFwaSIsImRhdGFDb25maWRlbmNlIiwiYnVzaW5lc3NJbnNpZ2h0cyIsInBhaW5Qb2ludHMiLCJjb21wZXRpdGl2ZUFkdmFudGFnZXMiLCJ0YWdzIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwidXNlUGlwZWxpbmVTdG9yZVdpdGhTdXBhYmFzZSIsInNldCIsImdldCIsInByb3NwZWN0cyIsInNlbGVjdGVkUHJvc3BlY3QiLCJzZXRTZWxlY3RlZFByb3NwZWN0IiwicHJvc3BlY3QiLCJpc0xvYWRpbmciLCJlcnJvciIsInNvY2tldCIsIndzQ29ubmVjdGVkIiwid3NDb25uZWN0aW5nIiwic3RhZ2VGaWx0ZXIiLCJzZXRTdGFnZUZpbHRlciIsInN0YWdlIiwiaW5kdXN0cnlGaWx0ZXIiLCJzZXRJbmR1c3RyeUZpbHRlciIsInNlYXJjaFF1ZXJ5Iiwic2V0U2VhcmNoUXVlcnkiLCJxdWVyeSIsImZldGNoUHJvc3BlY3RzIiwicmVzcG9uc2UiLCJmZXRjaCIsInJlc3VsdCIsImpzb24iLCJzdWNjZXNzIiwiZGF0YSIsIm1hcCIsImNvbnNvbGUiLCJtb3ZlUHJvc3BlY3QiLCJwcm9zcGVjdElkIiwibmV3U3RhZ2UiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwIiwidXBkYXRlUHJvc3BlY3RTY29yZSIsImFkZFByb3NwZWN0IiwidGVtcGVyYXR1cmUiLCJub3RlcyIsImlQcm9zcGVjdCIsImFkZE5vdGlmaWNhdGlvbiIsIm1lc3NhZ2UiLCJ1cGRhdGVQcm9zcGVjdCIsInVwZGF0ZXMiLCJ1cGRhdGVkSVByb3NwZWN0IiwiZGVsZXRlUHJvc3BlY3QiLCJmaW5kIiwiZmlsdGVyIiwiY29ubmVjdFdlYlNvY2tldCIsImNvbm5lY3RlZCIsInRyYW5zcG9ydHMiLCJ0aW1lb3V0IiwiZm9yY2VOZXciLCJvbiIsImxvZyIsInN1YnNjcmliZVRvQ2hhbmdlcyIsInJlYXNvbiIsImRpc2Nvbm5lY3RXZWJTb2NrZXQiLCJkaXNjb25uZWN0Iiwib2xkU3RhZ2UiLCJuZXdQcm9zcGVjdCIsInByb2dyZXNzIiwibGV2ZWwiLCJ1bnN1YnNjcmliZUZyb21DaGFuZ2VzIiwib2ZmIiwicmVzZWFyY2hRdWV1ZSIsImFkZFRvUmVzZWFyY2hRdWV1ZSIsInJlbW92ZUZyb21SZXNlYXJjaFF1ZXVlIiwiaXNSZXNlYXJjaGluZyIsInNldElzUmVzZWFyY2hpbmciLCJyZXNlYXJjaGluZyIsIm5vdGlmaWNhdGlvbnMiLCJub3RpZmljYXRpb24iLCJNYXRoIiwibm93IiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJuZXdOb3RpZmljYXRpb24iLCJ0aW1lc3RhbXAiLCJzZXRUaW1lb3V0IiwicmVtb3ZlTm90aWZpY2F0aW9uIiwibiIsImdldEZpbHRlcmVkUHJvc3BlY3RzIiwiZmlsdGVyZWQiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwiZ2V0U3RhZ2VDb3VudCIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./stores/usePipelineStoreWithSupabase.ts\n"));

/***/ })

});