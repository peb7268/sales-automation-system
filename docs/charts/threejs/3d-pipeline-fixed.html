<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js - 3D Pipeline Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #canvas {
            width: 100%;
            height: 600px;
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Three.js - 3D Sales Pipeline</h1>
        <div id="canvas"></div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.150.0/examples/jsm/controls/OrbitControls.js';

        const container = document.getElementById('canvas');
        const width = container.offsetWidth;
        const height = 600;

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        camera.position.set(0, 5, 10);

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        container.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        // Create pipeline stages
        const stages = [
            { name: 'Leads', height: 5, color: 0x4287f5, width: 2.5 },
            { name: 'Qualified', height: 4, color: 0x42f554, width: 2.2 },
            { name: 'Proposal', height: 3, color: 0xf5d442, width: 1.9 },
            { name: 'Negotiation', height: 2, color: 0xf59542, width: 1.6 },
            { name: 'Closed', height: 1.5, color: 0x42f5a1, width: 1.3 }
        ];

        stages.forEach((stage, index) => {
            // Create cylinder for each stage
            const geometry = new THREE.CylinderGeometry(
                stage.width - 0.3,
                stage.width,
                stage.height,
                32
            );
            const material = new THREE.MeshPhongMaterial({
                color: stage.color,
                transparent: true,
                opacity: 0.8
            });
            const cylinder = new THREE.Mesh(geometry, material);
            cylinder.position.y = stage.height / 2 + index * 0.1;
            cylinder.position.x = index * 3 - 6;
            scene.add(cylinder);

            // Add text (using sprites for simplicity)
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.font = '24px Arial';
            context.fillStyle = 'black';
            context.textAlign = 'center';
            context.fillText(stage.name, 128, 40);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.copy(cylinder.position);
            sprite.position.y += stage.height / 2 + 0.5;
            sprite.scale.set(2, 0.5, 1);
            scene.add(sprite);
        });

        // Add grid helper
        const gridHelper = new THREE.GridHelper(20, 20);
        scene.add(gridHelper);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            const newWidth = container.offsetWidth;
            camera.aspect = newWidth / height;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, height);
        });
    </script>
</body>
</html>