<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js - 3D Clustering</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; border-radius: 8px; padding: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        #canvas { width: 100%; height: 600px; }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <div class="container">
        <h1>Three.js - Customer Clustering Visualization</h1>
        <div id="canvas"></div>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const container = document.getElementById('canvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(75, container.offsetWidth / 600, 0.1, 1000);
        camera.position.set(0, 0, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.offsetWidth, 600);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Create clusters
        const clusters = [
            { center: new THREE.Vector3(-15, 10, 0), color: 0xff0000, count: 50 },
            { center: new THREE.Vector3(15, 10, 0), color: 0x00ff00, count: 40 },
            { center: new THREE.Vector3(0, -10, 0), color: 0x0000ff, count: 60 },
            { center: new THREE.Vector3(-10, -5, 10), color: 0xffff00, count: 35 },
            { center: new THREE.Vector3(10, -5, -10), color: 0xff00ff, count: 45 }
        ];

        const particles = new THREE.Group();

        clusters.forEach(cluster => {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color = new THREE.Color(cluster.color);

            for (let i = 0; i < cluster.count; i++) {
                const x = cluster.center.x + (Math.random() - 0.5) * 10;
                const y = cluster.center.y + (Math.random() - 0.5) * 10;
                const z = cluster.center.z + (Math.random() - 0.5) * 10;

                positions.push(x, y, z);
                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });

            const points = new THREE.Points(geometry, material);
            particles.add(points);

            // Add cluster center sphere
            const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
            const sphereMaterial = new THREE.MeshBasicMaterial({
                color: cluster.color,
                transparent: true,
                opacity: 0.3
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.copy(cluster.center);
            scene.add(sphere);
        });

        scene.add(particles);

        // Animation
        function animate() {
            requestAnimationFrame(animate);
            particles.rotation.y += 0.002;
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = container.offsetWidth / 600;
            camera.updateProjectionMatrix();
            renderer.setSize(container.offsetWidth, 600);
        });
    </script>
</body>
</html>